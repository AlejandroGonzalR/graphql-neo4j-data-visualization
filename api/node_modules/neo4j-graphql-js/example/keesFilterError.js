const neo4j = require('neo4j-driver');
const express = require('express');
const app = express();
const { ApolloServer } = require('apollo-server-express');
const { makeAugmentedSchema } = require('neo4j-graphql-js');

let conf = { encrypted: 'ENCRYPTION_OFF', disableLosslessIntegers: true };

const driver = neo4j.driver(
  'bolt://localhost:7687',
  neo4j.auth.basic('neo4j', 'letmein'),
  conf
);

// GraphQL Definition

// resolvers
const resolvers = {
  Query: {
    featuredItems: (root, args, context) => {
      let session = context.driver.session();
      let cql =
        'MATCH (product:Product)-[:HAS_ITEM]->(itm:Item)-[:HAS_FEATURE]->(f:Feature) WHERE product.partNumber = $partNumber AND f.name = $feature AND f.value = $val  WITH product, collect({shortDescription: itm.shortDescription, partNumber : itm.partNumber}) as items SKIP $offset LIMIT $first WITH product { partNumber : product.partNumber, shortDescription : product.shortDescription, Items: items }  as node RETURN node ';
      console.log(
        ' Executing query now make sure that the return object exactly matches the type definition'
      );
      return session.run(cql, args).then(result => {
        return result.records.map(record => {
          return record.get('node');
        });
      });
    }
  }
};

const typeDefs = `

type Product {
        partNumber: String
        shortDescription: String
        Items: [Item] @relation(name: "HAS_ITEM", direction: "OUT")
    }

type Item {
        shortDescription: String
        partNumber: String
        Features: [Feature] @relation(name: "HAS_FEATURE", direction: "OUT")
     }

type Feature {
        name: String
        value: String
		}
		

type Query {
	      featuredItems(partNumber: String, feature: String, val: String, first: Int = 10, offset: Int = 0): [Product]
    }
`;

const schema = makeAugmentedSchema({
  typeDefs,
  resolvers,
  config: { debug: true }
});

app.get('/hello', (req, res) =>
  res.send('Hello World! Greetings from my graphql and expressapi ')
);

app.get(
  '/featuredproducts/:partnumber/:feature/:featurevalue/:first/:offset',
  async function(req, res) {
    let args = {
      partNumber: req.params.partnumber,
      feature: req.params.feature,
      val: req.params.featurevalue,
      first: req.params.first,
      offset: req.params.offset
    };

    let session = driver.session();
    let cql =
      'MATCH (product:Product)-[:HAS_ITEM]->(itm:Item)-[:HAS_FEATURE]->(f:Feature) WHERE product.partNumber = $partNumber AND f.name = $feature AND f.value = $val  WITH product, collect({shortDescription: itm.shortDescription, partNumber : itm.partNumber}) as items SKIP toInteger($offset) LIMIT toInteger($first) WITH product { product: { partNumber : product.partNumber, shortDescription : product.shortDescription, items: items }  , feature : { name : $feature , value: $val }  } as node RETURN { data: node } as node';

    let rs = session.run(cql, args);
    res.writeHead(200, {
      'Content-Type': 'application/json',
      'Transfer-Encoding': 'chunked'
    });
    res.write('[');
    rs.subscribe({
      onNext: function(record) {
        res.write(JSON.stringify(record.get('node')) + '\n');
      },
      onCompleted: function() {
        res.write(']');
        res.end();
        session.close();
      },
      onError: function(error) {
        console.log(error);
        res.write('' + error);
        res.write(']');
        res.end();
      }
    });
  }
);

// bringin up the server

const server = new ApolloServer({ schema: schema, context: { driver } });

// Specify port and path for GraphQL endpoint
const port = 3000;
const path = '/graphql';

//
//Optionally, apply Express middleware for authentication, etc
//This also also allows us to specify a path for the GraphQL endpoint
//

server.applyMiddleware({ app, path });

app.listen({ port, path }, () => {
  console.log(`GraphQL server ready at http://localhost:${port}${path}`);
});
