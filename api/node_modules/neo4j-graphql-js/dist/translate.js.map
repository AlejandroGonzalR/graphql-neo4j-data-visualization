{"version":3,"sources":["../src/translate.js"],"names":["customCypherField","customCypher","cypherParams","schemaTypeRelation","initial","fieldName","fieldType","nestedVariable","variableName","headSelection","schemaType","resolveInfo","subSelection","skipLimit","commaIfTail","tailParams","fieldIsList","ofType","relationFieldOnNodeType","relDirection","relType","isInlineFragment","interfaceLabel","innerSchemaType","filterParams","temporalArgs","selections","temporalClauses","arrayFilterParams","_","pickBy","param","keyName","Array","isArray","value","allParams","queryParams","filter","safeVariableName","arrayPredicates","map","key","find","index","whereClauses","orderByParam","temporalOrdering","temporalOrderingFieldExists","name","length","join","buildSortMultiArgs","temporalTypeSelections","relationTypeFieldOnNodeType","innerSchemaTypeRelation","from","to","relationshipVariableName","nodeTypeFieldOnRelationType","fieldInfo","paramIndex","parentSelectionInfo","selectionInfo","rootType","relationTypeMutationPayloadField","directedNodeTypeFieldOnRelationType","fromTypeName","toTypeName","isFromField","isToField","temporalFieldRelationshipVariableName","temporalField","secondParentSelectionInfo","parentFieldName","parentFieldType","parentSchemaType","parentVariableName","secondParentVariableName","fieldIsArray","astNode","parentSchemaTypeRelation","temporalType","parentFilterParams","translateQuery","context","typeName","first","offset","_id","orderBy","otherParams","nullParams","nonNullParams","queryArgs","queryTypeCypherDirective","getCypherParams","outerSkipLimit","orderByValue","customQuery","argString","nodeQuery","Object","undefined","subQuery","subParams","params","cypherQueryArg","arguments","x","isScalarType","query","safeLabelName","arrayParams","args","arg","idWherePredicate","nullFieldPredicates","predicateClauses","predicate","translateMutation","mutationTypeCypherDirective","mutationInfo","customMutation","nodeCreate","nodeUpdate","nodeDelete","relationshipCreate","relationshipDelete","Error","statements","paramKey","preparedParams","paramStatements","primaryKeyArg","primaryKeyArgName","primaryKeyParam","updateParams","paramUpdateStatements","deletionVariableName","mutationMeta","relationshipNameArg","fromTypeArg","toTypeArg","schema","getMutationType","getFields","directives","e","typeMap","getTypeMap","fromType","fromVar","fromInputArg","type","fromInputAst","fromFields","fields","fromParam","fromTemporalArgs","toType","toVar","toInputArg","toInputAst","toFields","toParam","toTemporalArgs","relationshipName","lowercased","toLowerCase","dataInputArg","dataInputAst","dataFields","schemaTypeName","fromVariable","fromLabel","toVariable","toLabel","relationshipVariable","relationshipLabel","fromTemporalClauses","toTemporalClauses","fromRootVariable","toRootVariable","selectedTypes","selectionSet","reduce","temporalTypeFields","innerSelection","fieldTypeName","getFieldTypeName","innerSelectedTypes","push","temporalSubFields","t","subFieldName","field","substring","indexOf","values","includes"],"mappings":"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","file":"translate.js","sourcesContent":["import {\n  isArrayType,\n  cypherDirectiveArgs,\n  safeLabel,\n  safeVar,\n  getFilterParams,\n  lowFirstLetter,\n  isAddMutation,\n  isCreateMutation,\n  isUpdateMutation,\n  isRemoveMutation,\n  isDeleteMutation,\n  computeOrderBy,\n  innerFilterParams,\n  paramsToString,\n  filterNullParams,\n  getOuterSkipLimit,\n  getQueryCypherDirective,\n  getMutationArguments,\n  possiblySetFirstId,\n  buildCypherParameters,\n  getQueryArguments,\n  initializeMutationParams,\n  getMutationCypherDirective,\n  isNodeType,\n  getRelationTypeDirectiveArgs,\n  isRelationTypeDirectedField,\n  isRelationTypePayload,\n  isRootSelection,\n  splitSelectionParameters,\n  getTemporalArguments,\n  temporalPredicateClauses,\n  isTemporalType,\n  isGraphqlScalarType\n} from './utils';\nimport { getNamedType } from 'graphql';\nimport { buildCypherSelection } from './selections';\nimport _ from 'lodash';\n\nexport const customCypherField = ({\n  customCypher,\n  cypherParams,\n  schemaTypeRelation,\n  initial,\n  fieldName,\n  fieldType,\n  nestedVariable,\n  variableName,\n  headSelection,\n  schemaType,\n  resolveInfo,\n  subSelection,\n  skipLimit,\n  commaIfTail,\n  tailParams\n}) => {\n  if (schemaTypeRelation) {\n    variableName = `${variableName}_relation`;\n  }\n  const fieldIsList = !!fieldType.ofType;\n  // similar: [ x IN apoc.cypher.runFirstColumn(\"WITH {this} AS this MATCH (this)--(:Genre)--(o:Movie) RETURN o\", {this: movie}, true) |x {.title}][1..2])\n  return {\n    initial: `${initial}${fieldName}: ${\n      fieldIsList ? '' : 'head('\n    }[ ${nestedVariable} IN apoc.cypher.runFirstColumn(\"${customCypher}\", ${cypherDirectiveArgs(\n      variableName,\n      cypherParams,\n      headSelection,\n      schemaType,\n      resolveInfo\n    )}, true) | ${nestedVariable} {${subSelection[0]}}]${\n      fieldIsList ? '' : ')'\n    }${skipLimit} ${commaIfTail}`,\n    ...tailParams\n  };\n};\n\nexport const relationFieldOnNodeType = ({\n  initial,\n  fieldName,\n  fieldType,\n  variableName,\n  relDirection,\n  relType,\n  nestedVariable,\n  isInlineFragment,\n  interfaceLabel,\n  innerSchemaType,\n  filterParams,\n  temporalArgs,\n  selections,\n  schemaType,\n  subSelection,\n  skipLimit,\n  commaIfTail,\n  tailParams,\n  temporalClauses\n}) => {\n  const arrayFilterParams = _.pickBy(\n    filterParams,\n    (param, keyName) => Array.isArray(param.value) && !('orderBy' === keyName)\n  );\n  const allParams = innerFilterParams(filterParams, temporalArgs);\n  const queryParams = paramsToString(\n    _.filter(allParams, param => !Array.isArray(param.value))\n  );\n  const safeVariableName = safeVar(nestedVariable);\n  const arrayPredicates = _.map(arrayFilterParams, (value, key) => {\n    const param = _.find(allParams, param => param.key === key);\n    return `${safeVariableName}.${safeVar(key)} IN $${\n      param.value.index\n    }_${key}`;\n  });\n  const whereClauses = [...temporalClauses, ...arrayPredicates];\n  const orderByParam = filterParams['orderBy'];\n  const temporalOrdering = temporalOrderingFieldExists(\n    schemaType,\n    filterParams\n  );\n  return {\n    initial: `${initial}${fieldName}: ${\n      !isArrayType(fieldType) ? 'head(' : ''\n    }${\n      orderByParam\n        ? temporalOrdering\n          ? `[sortedElement IN apoc.coll.sortMulti(`\n          : `apoc.coll.sortMulti(`\n        : ''\n    }[(${safeVar(variableName)})${\n      relDirection === 'in' || relDirection === 'IN' ? '<' : ''\n    }-[:${safeLabel(relType)}]-${\n      relDirection === 'out' || relDirection === 'OUT' ? '>' : ''\n    }(${safeVariableName}:${safeLabel(\n      isInlineFragment ? interfaceLabel : innerSchemaType.name\n    )}${queryParams})${\n      whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : ''\n    } | ${nestedVariable} {${\n      isInlineFragment\n        ? 'FRAGMENT_TYPE: \"' + interfaceLabel + '\",' + subSelection[0]\n        : subSelection[0]\n    }}]${\n      orderByParam\n        ? `, [${buildSortMultiArgs(orderByParam)}])${\n            temporalOrdering\n              ? ` | sortedElement { .*,  ${temporalTypeSelections(\n                  selections,\n                  innerSchemaType\n                )}}]`\n              : ``\n          }`\n        : ''\n    }${!isArrayType(fieldType) ? ')' : ''}${skipLimit} ${commaIfTail}`,\n    ...tailParams\n  };\n};\n\nexport const relationTypeFieldOnNodeType = ({\n  innerSchemaTypeRelation,\n  initial,\n  fieldName,\n  subSelection,\n  skipLimit,\n  commaIfTail,\n  tailParams,\n  fieldType,\n  variableName,\n  schemaType,\n  nestedVariable,\n  queryParams,\n  filterParams,\n  temporalArgs\n}) => {\n  if (innerSchemaTypeRelation.from === innerSchemaTypeRelation.to) {\n    return {\n      initial: `${initial}${fieldName}: {${\n        subSelection[0]\n      }}${skipLimit} ${commaIfTail}`,\n      ...tailParams\n    };\n  }\n  const relationshipVariableName = `${nestedVariable}_relation`;\n  const temporalClauses = temporalPredicateClauses(\n    filterParams,\n    relationshipVariableName,\n    temporalArgs\n  );\n  return {\n    initial: `${initial}${fieldName}: ${\n      !isArrayType(fieldType) ? 'head(' : ''\n    }[(${safeVar(variableName)})${\n      schemaType.name === innerSchemaTypeRelation.to ? '<' : ''\n    }-[${safeVar(relationshipVariableName)}:${safeLabel(\n      innerSchemaTypeRelation.name\n    )}${queryParams}]-${\n      schemaType.name === innerSchemaTypeRelation.from ? '>' : ''\n    }(:${safeLabel(\n      schemaType.name === innerSchemaTypeRelation.from\n        ? innerSchemaTypeRelation.to\n        : innerSchemaTypeRelation.from\n    )}) ${\n      temporalClauses.length > 0\n        ? `WHERE ${temporalClauses.join(' AND ')} `\n        : ''\n    }| ${relationshipVariableName} {${subSelection[0]}}]${\n      !isArrayType(fieldType) ? ')' : ''\n    }${skipLimit} ${commaIfTail}`,\n    ...tailParams\n  };\n};\n\nexport const nodeTypeFieldOnRelationType = ({\n  fieldInfo,\n  schemaTypeRelation,\n  innerSchemaType,\n  isInlineFragment,\n  interfaceLabel,\n  paramIndex,\n  schemaType,\n  filterParams,\n  temporalArgs,\n  parentSelectionInfo\n}) => {\n  if (\n    isRootSelection({\n      selectionInfo: parentSelectionInfo,\n      rootType: 'relationship'\n    }) &&\n    isRelationTypeDirectedField(fieldInfo.fieldName)\n  ) {\n    return relationTypeMutationPayloadField({\n      ...fieldInfo,\n      parentSelectionInfo\n    });\n  }\n  // Normal case of schemaType with a relationship directive\n  return directedNodeTypeFieldOnRelationType({\n    ...fieldInfo,\n    schemaTypeRelation,\n    innerSchemaType,\n    isInlineFragment,\n    interfaceLabel,\n    paramIndex,\n    schemaType,\n    filterParams,\n    temporalArgs\n  });\n};\n\nconst relationTypeMutationPayloadField = ({\n  initial,\n  fieldName,\n  variableName,\n  subSelection,\n  skipLimit,\n  commaIfTail,\n  tailParams,\n  parentSelectionInfo\n}) => {\n  const safeVariableName = safeVar(variableName);\n  return {\n    initial: `${initial}${fieldName}: ${safeVariableName} {${\n      subSelection[0]\n    }}${skipLimit} ${commaIfTail}`,\n    ...tailParams,\n    variableName:\n      fieldName === 'from' ? parentSelectionInfo.to : parentSelectionInfo.from\n  };\n};\n\nconst directedNodeTypeFieldOnRelationType = ({\n  initial,\n  fieldName,\n  fieldType,\n  variableName,\n  queryParams,\n  nestedVariable,\n  subSelection,\n  skipLimit,\n  commaIfTail,\n  tailParams,\n  schemaTypeRelation,\n  innerSchemaType,\n  isInlineFragment,\n  interfaceLabel,\n  filterParams,\n  temporalArgs\n}) => {\n  const relType = schemaTypeRelation.name;\n  const fromTypeName = schemaTypeRelation.from;\n  const toTypeName = schemaTypeRelation.to;\n  const isFromField = fieldName === fromTypeName || fieldName === 'from';\n  const isToField = fieldName === toTypeName || fieldName === 'to';\n  // Since the translations are significantly different,\n  // we first check whether the relationship is reflexive\n  if (fromTypeName === toTypeName) {\n    const relationshipVariableName = `${variableName}_${\n      isFromField ? 'from' : 'to'\n    }_relation`;\n    if (isRelationTypeDirectedField(fieldName)) {\n      const temporalFieldRelationshipVariableName = `${nestedVariable}_relation`;\n      const temporalClauses = temporalPredicateClauses(\n        filterParams,\n        temporalFieldRelationshipVariableName,\n        temporalArgs\n      );\n      return {\n        initial: `${initial}${fieldName}: ${\n          !isArrayType(fieldType) ? 'head(' : ''\n        }[(${safeVar(variableName)})${isFromField ? '<' : ''}-[${safeVar(\n          relationshipVariableName\n        )}:${safeLabel(relType)}${queryParams}]-${\n          isToField ? '>' : ''\n        }(${safeVar(nestedVariable)}:${safeLabel(\n          isInlineFragment ? interfaceLabel : fromTypeName\n        )}) ${\n          temporalClauses.length > 0\n            ? `WHERE ${temporalClauses.join(' AND ')} `\n            : ''\n        }| ${relationshipVariableName} {${\n          isInlineFragment\n            ? 'FRAGMENT_TYPE: \"' + interfaceLabel + '\",' + subSelection[0]\n            : subSelection[0]\n        }}]${!isArrayType(fieldType) ? ')' : ''}${skipLimit} ${commaIfTail}`,\n        ...tailParams\n      };\n    } else {\n      // Case of a renamed directed field\n      // e.g., 'from: Movie' -> 'Movie: Movie'\n      return {\n        initial: `${initial}${fieldName}: ${variableName} {${\n          subSelection[0]\n        }}${skipLimit} ${commaIfTail}`,\n        ...tailParams\n      };\n    }\n  } else {\n    variableName = variableName + '_relation';\n    return {\n      initial: `${initial}${fieldName}: ${\n        !isArrayType(fieldType) ? 'head(' : ''\n      }[(:${safeLabel(isFromField ? toTypeName : fromTypeName)})${\n        isFromField ? '<' : ''\n      }-[${safeVar(variableName)}]-${isToField ? '>' : ''}(${safeVar(\n        nestedVariable\n      )}:${safeLabel(\n        isInlineFragment ? interfaceLabel : innerSchemaType.name\n      )}${queryParams}) | ${nestedVariable} {${\n        isInlineFragment\n          ? 'FRAGMENT_TYPE: \"' + interfaceLabel + '\",' + subSelection[0]\n          : subSelection[0]\n      }}]${!isArrayType(fieldType) ? ')' : ''}${skipLimit} ${commaIfTail}`,\n      ...tailParams\n    };\n  }\n};\n\nexport const temporalField = ({\n  initial,\n  fieldName,\n  commaIfTail,\n  tailParams,\n  parentSelectionInfo,\n  secondParentSelectionInfo\n}) => {\n  const parentFieldName = parentSelectionInfo.fieldName;\n  const parentFieldType = parentSelectionInfo.fieldType;\n  const parentSchemaType = parentSelectionInfo.schemaType;\n  const parentVariableName = parentSelectionInfo.variableName;\n  const secondParentVariableName = secondParentSelectionInfo.variableName;\n  // Initially assume that the parent type of the temporal type\n  // containing this temporal field was a node\n  let variableName = parentVariableName;\n  let fieldIsArray = isArrayType(parentFieldType);\n  if (parentSchemaType && !isNodeType(parentSchemaType.astNode)) {\n    // initial assumption wrong, build appropriate relationship variable\n    if (\n      isRootSelection({\n        selectionInfo: secondParentSelectionInfo,\n        rootType: 'relationship'\n      })\n    ) {\n      // If the second parent selection scope above is the root\n      // then we need to use the root variableName\n      variableName = `${secondParentVariableName}_relation`;\n    } else if (isRelationTypePayload(parentSchemaType)) {\n      const parentSchemaTypeRelation = getRelationTypeDirectiveArgs(\n        parentSchemaType.astNode\n      );\n      if (parentSchemaTypeRelation.from === parentSchemaTypeRelation.to) {\n        variableName = `${variableName}_relation`;\n      } else {\n        variableName = `${variableName}_relation`;\n      }\n    }\n  }\n  return {\n    initial: `${initial} ${fieldName}: ${\n      fieldIsArray\n        ? `${\n            fieldName === 'formatted'\n              ? `toString(TEMPORAL_INSTANCE)`\n              : `TEMPORAL_INSTANCE.${fieldName}`\n          } ${commaIfTail}`\n        : `${\n            fieldName === 'formatted'\n              ? `toString(${safeVar(\n                  variableName\n                )}.${parentFieldName}) ${commaIfTail}`\n              : `${safeVar(\n                  variableName\n                )}.${parentFieldName}.${fieldName} ${commaIfTail}`\n          }`\n    }`,\n    ...tailParams\n  };\n};\n\nexport const temporalType = ({\n  initial,\n  fieldName,\n  subSelection,\n  commaIfTail,\n  tailParams,\n  variableName,\n  nestedVariable,\n  fieldType,\n  schemaType,\n  schemaTypeRelation,\n  parentSelectionInfo\n}) => {\n  const parentVariableName = parentSelectionInfo.variableName;\n  const parentFilterParams = parentSelectionInfo.filterParams;\n  const parentSchemaType = parentSelectionInfo.schemaType;\n  const safeVariableName = safeVar(variableName);\n  let fieldIsArray = isArrayType(fieldType);\n  if (!isNodeType(schemaType.astNode)) {\n    if (\n      isRelationTypePayload(schemaType) &&\n      schemaTypeRelation.from === schemaTypeRelation.to\n    ) {\n      variableName = `${nestedVariable}_relation`;\n    } else {\n      if (fieldIsArray) {\n        if (\n          isRootSelection({\n            selectionInfo: parentSelectionInfo,\n            rootType: 'relationship'\n          })\n        ) {\n          if (schemaTypeRelation.from === schemaTypeRelation.to) {\n            variableName = `${parentVariableName}_relation`;\n          } else {\n            variableName = `${parentVariableName}_relation`;\n          }\n        } else {\n          variableName = `${variableName}_relation`;\n        }\n      } else {\n        variableName = `${nestedVariable}_relation`;\n      }\n    }\n  }\n  return {\n    initial: `${initial}${fieldName}: ${\n      fieldIsArray\n        ? `reduce(a = [], TEMPORAL_INSTANCE IN ${variableName}.${fieldName} | a + {${\n            subSelection[0]\n          }})${commaIfTail}`\n        : temporalOrderingFieldExists(parentSchemaType, parentFilterParams)\n        ? `${safeVariableName}.${fieldName}${commaIfTail}`\n        : `{${subSelection[0]}}${commaIfTail}`\n    }`,\n    ...tailParams\n  };\n};\n\n// Query API root operation branch\nexport const translateQuery = ({\n  resolveInfo,\n  context,\n  selections,\n  variableName,\n  typeName,\n  schemaType,\n  first,\n  offset,\n  _id,\n  orderBy,\n  otherParams\n}) => {\n  const [nullParams, nonNullParams] = filterNullParams({\n    offset,\n    first,\n    otherParams\n  });\n  const filterParams = getFilterParams(nonNullParams);\n  const queryArgs = getQueryArguments(resolveInfo);\n  const temporalArgs = getTemporalArguments(queryArgs);\n  const queryTypeCypherDirective = getQueryCypherDirective(resolveInfo);\n  const cypherParams = getCypherParams(context);\n  const queryParams = paramsToString(\n    innerFilterParams(\n      filterParams,\n      temporalArgs,\n      null,\n      queryTypeCypherDirective ? true : false\n    ),\n    cypherParams\n  );\n  const safeVariableName = safeVar(variableName);\n  const temporalClauses = temporalPredicateClauses(\n    filterParams,\n    safeVariableName,\n    temporalArgs\n  );\n  const outerSkipLimit = getOuterSkipLimit(first);\n  const orderByValue = computeOrderBy(resolveInfo, selections);\n\n  if (queryTypeCypherDirective) {\n    return customQuery({\n      resolveInfo,\n      cypherParams,\n      schemaType,\n      argString: queryParams,\n      selections,\n      variableName,\n      typeName,\n      orderByValue,\n      outerSkipLimit,\n      queryTypeCypherDirective,\n      nonNullParams\n    });\n  } else {\n    return nodeQuery({\n      resolveInfo,\n      cypherParams,\n      schemaType,\n      argString: queryParams,\n      selections,\n      variableName,\n      typeName,\n      temporalClauses,\n      orderByValue,\n      outerSkipLimit,\n      nullParams,\n      nonNullParams,\n      filterParams,\n      temporalArgs,\n      _id\n    });\n  }\n};\n\nconst getCypherParams = context => {\n  return context &&\n    context.cypherParams &&\n    context.cypherParams instanceof Object &&\n    Object.keys(context.cypherParams).length > 0\n    ? context.cypherParams\n    : undefined;\n};\n\n// Custom read operation\nconst customQuery = ({\n  resolveInfo,\n  cypherParams,\n  schemaType,\n  argString,\n  selections,\n  variableName,\n  typeName,\n  orderByValue,\n  outerSkipLimit,\n  queryTypeCypherDirective,\n  nonNullParams\n}) => {\n  const safeVariableName = safeVar(variableName);\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: '',\n    cypherParams,\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  const params = { ...nonNullParams, ...subParams };\n  if (cypherParams) {\n    params['cypherParams'] = cypherParams;\n  }\n  // QueryType with a @cypher directive\n  const cypherQueryArg = queryTypeCypherDirective.arguments.find(x => {\n    return x.name.value === 'statement';\n  });\n  const isScalarType = isGraphqlScalarType(schemaType);\n  const temporalType = isTemporalType(schemaType.name);\n  const query = `WITH apoc.cypher.runFirstColumn(\"${\n    cypherQueryArg.value.value\n  }\", ${argString ||\n    'null'}, True) AS x UNWIND x AS ${safeVariableName} RETURN ${safeVariableName} ${\n    // Don't add subQuery for scalar type payloads\n    // FIXME: fix subselection translation for temporal type payload\n    !temporalType && !isScalarType\n      ? `{${subQuery}} AS ${safeVariableName}${orderByValue}`\n      : ''\n  } ${outerSkipLimit}`;\n  return [query, params];\n};\n\n// Generated API\nconst nodeQuery = ({\n  resolveInfo,\n  cypherParams,\n  schemaType,\n  selections,\n  variableName,\n  typeName,\n  temporalClauses,\n  orderByValue,\n  outerSkipLimit,\n  nullParams,\n  nonNullParams,\n  filterParams,\n  temporalArgs,\n  _id\n}) => {\n  const safeVariableName = safeVar(variableName);\n  const safeLabelName = safeLabel(typeName);\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: '',\n    cypherParams,\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  const params = { ...nonNullParams, ...subParams };\n  if (cypherParams) {\n    params['cypherParams'] = cypherParams;\n  }\n  const arrayParams = _.pickBy(filterParams, Array.isArray);\n  const args = innerFilterParams(filterParams, temporalArgs);\n\n  const argString = paramsToString(\n    _.filter(args, arg => !Array.isArray(arg.value))\n  );\n\n  const idWherePredicate =\n    typeof _id !== 'undefined' ? `ID(${safeVariableName})=${_id}` : '';\n\n  const nullFieldPredicates = Object.keys(nullParams).map(\n    key => `${variableName}.${key} IS NULL`\n  );\n\n  const arrayPredicates = _.map(\n    arrayParams,\n    (value, key) => `${safeVariableName}.${safeVar(key)} IN $${key}`\n  );\n\n  const predicateClauses = [\n    idWherePredicate,\n    ...nullFieldPredicates,\n    ...temporalClauses,\n    ...arrayPredicates\n  ]\n    .filter(predicate => !!predicate)\n    .join(' AND ');\n  const predicate = predicateClauses ? `WHERE ${predicateClauses} ` : '';\n\n  const query =\n    `MATCH (${safeVariableName}:${safeLabelName} ${argString}) ${predicate}` +\n    `RETURN ${safeVariableName} {${subQuery}} AS ${safeVariableName}${orderByValue} ${outerSkipLimit}`;\n\n  return [query, params];\n};\n\n// Mutation API root operation branch\nexport const translateMutation = ({\n  resolveInfo,\n  context,\n  schemaType,\n  selections,\n  variableName,\n  typeName,\n  first,\n  offset,\n  otherParams\n}) => {\n  const outerSkipLimit = getOuterSkipLimit(first);\n  const orderByValue = computeOrderBy(resolveInfo, selections);\n  const mutationTypeCypherDirective = getMutationCypherDirective(resolveInfo);\n  const params = initializeMutationParams({\n    resolveInfo,\n    mutationTypeCypherDirective,\n    first,\n    otherParams,\n    offset\n  });\n  const mutationInfo = {\n    params,\n    selections,\n    schemaType,\n    resolveInfo\n  };\n  if (mutationTypeCypherDirective) {\n    return customMutation({\n      ...mutationInfo,\n      context,\n      mutationTypeCypherDirective,\n      variableName,\n      orderByValue,\n      outerSkipLimit\n    });\n  } else if (isCreateMutation(resolveInfo)) {\n    return nodeCreate({\n      ...mutationInfo,\n      variableName,\n      typeName\n    });\n  } else if (isUpdateMutation(resolveInfo)) {\n    return nodeUpdate({\n      ...mutationInfo,\n      variableName,\n      typeName\n    });\n  } else if (isDeleteMutation(resolveInfo)) {\n    return nodeDelete({\n      ...mutationInfo,\n      variableName,\n      typeName\n    });\n  } else if (isAddMutation(resolveInfo)) {\n    return relationshipCreate({\n      ...mutationInfo\n    });\n  } else if (isRemoveMutation(resolveInfo)) {\n    return relationshipDelete({\n      ...mutationInfo,\n      variableName\n    });\n  } else {\n    // throw error - don't know how to handle this type of mutation\n    throw new Error(\n      'Do not know how to handle this type of mutation. Mutation does not follow naming convention.'\n    );\n  }\n};\n\n// Custom write operation\nconst customMutation = ({\n  params,\n  context,\n  mutationTypeCypherDirective,\n  selections,\n  variableName,\n  schemaType,\n  resolveInfo,\n  orderByValue,\n  outerSkipLimit\n}) => {\n  const cypherParams = getCypherParams(context);\n  const safeVariableName = safeVar(variableName);\n  // FIXME: support IN for multiple values -> WHERE\n  const argString = paramsToString(\n    innerFilterParams(\n      getFilterParams(params.params || params),\n      null,\n      null,\n      true\n    ),\n    cypherParams\n  );\n  const cypherQueryArg = mutationTypeCypherDirective.arguments.find(x => {\n    return x.name.value === 'statement';\n  });\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: '',\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  const isScalarType = isGraphqlScalarType(schemaType);\n  const temporalType = isTemporalType(schemaType.name);\n  params = { ...params, ...subParams };\n  if (cypherParams) {\n    params['cypherParams'] = cypherParams;\n  }\n  const query = `CALL apoc.cypher.doIt(\"${\n    cypherQueryArg.value.value\n  }\", ${argString}) YIELD value\n    WITH apoc.map.values(value, [keys(value)[0]])[0] AS ${safeVariableName}\n    RETURN ${safeVariableName} ${\n    !temporalType && !isScalarType\n      ? `{${subQuery}} AS ${safeVariableName}${orderByValue} ${outerSkipLimit}`\n      : ''\n  }`;\n  return [query, params];\n};\n\n// Generated API\n// Node Create - Update - Delete\nconst nodeCreate = ({\n  variableName,\n  typeName,\n  selections,\n  schemaType,\n  resolveInfo,\n  params\n}) => {\n  const safeVariableName = safeVar(variableName);\n  const safeLabelName = safeLabel(typeName);\n  let statements = [];\n  const args = getMutationArguments(resolveInfo);\n  statements = possiblySetFirstId({\n    args,\n    statements,\n    params: params.params\n  });\n  const [preparedParams, paramStatements] = buildCypherParameters({\n    args,\n    statements,\n    params,\n    paramKey: 'params'\n  });\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: ``,\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  params = { ...preparedParams, ...subParams };\n  const query = `\n    CREATE (${safeVariableName}:${safeLabelName} {${paramStatements.join(',')}})\n    RETURN ${safeVariableName} {${subQuery}} AS ${safeVariableName}\n  `;\n  return [query, params];\n};\n\nconst nodeUpdate = ({\n  resolveInfo,\n  variableName,\n  typeName,\n  selections,\n  schemaType,\n  params\n}) => {\n  const safeVariableName = safeVar(variableName);\n  const safeLabelName = safeLabel(typeName);\n  const args = getMutationArguments(resolveInfo);\n  const primaryKeyArg = args[0];\n  const primaryKeyArgName = primaryKeyArg.name.value;\n  const temporalArgs = getTemporalArguments(args);\n  const [primaryKeyParam, updateParams] = splitSelectionParameters(\n    params,\n    primaryKeyArgName,\n    'params'\n  );\n  const temporalClauses = temporalPredicateClauses(\n    primaryKeyParam,\n    safeVariableName,\n    temporalArgs,\n    'params'\n  );\n  const predicateClauses = [...temporalClauses]\n    .filter(predicate => !!predicate)\n    .join(' AND ');\n  const predicate = predicateClauses ? `WHERE ${predicateClauses} ` : '';\n  let [preparedParams, paramUpdateStatements] = buildCypherParameters({\n    args,\n    params: updateParams,\n    paramKey: 'params'\n  });\n  let query = `MATCH (${safeVariableName}:${safeLabelName}${\n    predicate !== ''\n      ? `) ${predicate} `\n      : `{${primaryKeyArgName}: $params.${primaryKeyArgName}})`\n  }\n  `;\n  if (paramUpdateStatements.length > 0) {\n    query += `SET ${safeVariableName} += {${paramUpdateStatements.join(',')}} `;\n  }\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: ``,\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  preparedParams.params[primaryKeyArgName] = primaryKeyParam[primaryKeyArgName];\n  params = { ...preparedParams, ...subParams };\n  query += `RETURN ${safeVariableName} {${subQuery}} AS ${safeVariableName}`;\n  return [query, params];\n};\n\nconst nodeDelete = ({\n  resolveInfo,\n  selections,\n  variableName,\n  typeName,\n  schemaType,\n  params\n}) => {\n  const safeVariableName = safeVar(variableName);\n  const safeLabelName = safeLabel(typeName);\n  const args = getMutationArguments(resolveInfo);\n  const primaryKeyArg = args[0];\n  const primaryKeyArgName = primaryKeyArg.name.value;\n  const temporalArgs = getTemporalArguments(args);\n  const [primaryKeyParam] = splitSelectionParameters(params, primaryKeyArgName);\n  const temporalClauses = temporalPredicateClauses(\n    primaryKeyParam,\n    safeVariableName,\n    temporalArgs\n  );\n  let [preparedParams] = buildCypherParameters({ args, params });\n  let query = `MATCH (${safeVariableName}:${safeLabelName}${\n    temporalClauses.length > 0\n      ? `) WHERE ${temporalClauses.join(' AND ')}`\n      : ` {${primaryKeyArgName}: $${primaryKeyArgName}})`\n  }`;\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: ``,\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1\n  });\n  params = { ...preparedParams, ...subParams };\n  const deletionVariableName = safeVar(`${variableName}_toDelete`);\n  // Cannot execute a map projection on a deleted node in Neo4j\n  // so the projection is executed and aliased before the delete\n  query += `\nWITH ${safeVariableName} AS ${deletionVariableName}, ${safeVariableName} {${subQuery}} AS ${safeVariableName}\nDETACH DELETE ${deletionVariableName}\nRETURN ${safeVariableName}`;\n  return [query, params];\n};\n\n// Relation Add / Remove\nconst relationshipCreate = ({\n  resolveInfo,\n  selections,\n  schemaType,\n  params\n}) => {\n  let mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;\n  try {\n    mutationMeta = resolveInfo.schema\n      .getMutationType()\n      .getFields()\n      [resolveInfo.fieldName].astNode.directives.find(x => {\n        return x.name.value === 'MutationMeta';\n      });\n  } catch (e) {\n    throw new Error(\n      'Missing required MutationMeta directive on add relationship directive'\n    );\n  }\n\n  try {\n    relationshipNameArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'relationship';\n    });\n    fromTypeArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'from';\n    });\n    toTypeArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'to';\n    });\n  } catch (e) {\n    throw new Error(\n      'Missing required argument in MutationMeta directive (relationship, from, or to)'\n    );\n  }\n\n  //TODO: need to handle one-to-one and one-to-many\n  const args = getMutationArguments(resolveInfo);\n  const typeMap = resolveInfo.schema.getTypeMap();\n\n  const fromType = fromTypeArg.value.value;\n  const fromVar = `${lowFirstLetter(fromType)}_from`;\n  const fromInputArg = args.find(e => e.name.value === 'from').type;\n  const fromInputAst =\n    typeMap[getNamedType(fromInputArg).type.name.value].astNode;\n  const fromFields = fromInputAst.fields;\n  const fromParam = fromFields[0].name.value;\n  const fromTemporalArgs = getTemporalArguments(fromFields);\n\n  const toType = toTypeArg.value.value;\n  const toVar = `${lowFirstLetter(toType)}_to`;\n  const toInputArg = args.find(e => e.name.value === 'to').type;\n  const toInputAst = typeMap[getNamedType(toInputArg).type.name.value].astNode;\n  const toFields = toInputAst.fields;\n  const toParam = toFields[0].name.value;\n  const toTemporalArgs = getTemporalArguments(toFields);\n\n  const relationshipName = relationshipNameArg.value.value;\n  const lowercased = relationshipName.toLowerCase();\n  const dataInputArg = args.find(e => e.name.value === 'data');\n  const dataInputAst = dataInputArg\n    ? typeMap[getNamedType(dataInputArg.type).type.name.value].astNode\n    : undefined;\n  const dataFields = dataInputAst ? dataInputAst.fields : [];\n\n  const [preparedParams, paramStatements] = buildCypherParameters({\n    args: dataFields,\n    params,\n    paramKey: 'data'\n  });\n  const schemaTypeName = safeVar(schemaType);\n  const fromVariable = safeVar(fromVar);\n  const fromLabel = safeLabel(fromType);\n  const toVariable = safeVar(toVar);\n  const toLabel = safeLabel(toType);\n  const relationshipVariable = safeVar(lowercased + '_relation');\n  const relationshipLabel = safeLabel(relationshipName);\n  const fromTemporalClauses = temporalPredicateClauses(\n    preparedParams.from,\n    fromVariable,\n    fromTemporalArgs,\n    'from'\n  );\n  const toTemporalClauses = temporalPredicateClauses(\n    preparedParams.to,\n    toVariable,\n    toTemporalArgs,\n    'to'\n  );\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: '',\n    selections,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1,\n    parentSelectionInfo: {\n      rootType: 'relationship',\n      from: fromVar,\n      to: toVar,\n      variableName: lowercased\n    },\n    variableName: schemaType.name === fromType ? `${toVar}` : `${fromVar}`\n  });\n  params = { ...preparedParams, ...subParams };\n  let query = `\n      MATCH (${fromVariable}:${fromLabel} ${\n    fromTemporalClauses && fromTemporalClauses.length > 0\n      ? // uses either a WHERE clause for managed type primary keys (temporal, etc.)\n        `) WHERE ${fromTemporalClauses.join(' AND ')} `\n      : // or a an internal matching clause for normal, scalar property primary keys\n        // NOTE this will need to change if we at some point allow for multi field node selection\n        `{${fromParam}: $from.${fromParam}})`\n  }\n      MATCH (${toVariable}:${toLabel} ${\n    toTemporalClauses && toTemporalClauses.length > 0\n      ? `) WHERE ${toTemporalClauses.join(' AND ')} `\n      : `{${toParam}: $to.${toParam}})`\n  }\n      CREATE (${fromVariable})-[${relationshipVariable}:${relationshipLabel}${\n    paramStatements.length > 0 ? ` {${paramStatements.join(',')}}` : ''\n  }]->(${toVariable})\n      RETURN ${relationshipVariable} { ${subQuery} } AS ${schemaTypeName};\n    `;\n  return [query, params];\n};\n\nconst relationshipDelete = ({\n  resolveInfo,\n  selections,\n  variableName,\n  schemaType,\n  params\n}) => {\n  let mutationMeta, relationshipNameArg, fromTypeArg, toTypeArg;\n  try {\n    mutationMeta = resolveInfo.schema\n      .getMutationType()\n      .getFields()\n      [resolveInfo.fieldName].astNode.directives.find(x => {\n        return x.name.value === 'MutationMeta';\n      });\n  } catch (e) {\n    throw new Error(\n      'Missing required MutationMeta directive on add relationship directive'\n    );\n  }\n\n  try {\n    relationshipNameArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'relationship';\n    });\n    fromTypeArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'from';\n    });\n    toTypeArg = mutationMeta.arguments.find(x => {\n      return x.name.value === 'to';\n    });\n  } catch (e) {\n    throw new Error(\n      'Missing required argument in MutationMeta directive (relationship, from, or to)'\n    );\n  }\n\n  //TODO: need to handle one-to-one and one-to-many\n  const args = getMutationArguments(resolveInfo);\n  const typeMap = resolveInfo.schema.getTypeMap();\n\n  const fromType = fromTypeArg.value.value;\n  const fromVar = `${lowFirstLetter(fromType)}_from`;\n  const fromInputArg = args.find(e => e.name.value === 'from').type;\n  const fromInputAst =\n    typeMap[getNamedType(fromInputArg).type.name.value].astNode;\n  const fromFields = fromInputAst.fields;\n  const fromParam = fromFields[0].name.value;\n  const fromTemporalArgs = getTemporalArguments(fromFields);\n\n  const toType = toTypeArg.value.value;\n  const toVar = `${lowFirstLetter(toType)}_to`;\n  const toInputArg = args.find(e => e.name.value === 'to').type;\n  const toInputAst = typeMap[getNamedType(toInputArg).type.name.value].astNode;\n  const toFields = toInputAst.fields;\n  const toParam = toFields[0].name.value;\n  const toTemporalArgs = getTemporalArguments(toFields);\n\n  const relationshipName = relationshipNameArg.value.value;\n\n  const schemaTypeName = safeVar(schemaType);\n  const fromVariable = safeVar(fromVar);\n  const fromLabel = safeLabel(fromType);\n  const toVariable = safeVar(toVar);\n  const toLabel = safeLabel(toType);\n  const relationshipVariable = safeVar(fromVar + toVar);\n  const relationshipLabel = safeLabel(relationshipName);\n  const fromRootVariable = safeVar('_' + fromVar);\n  const toRootVariable = safeVar('_' + toVar);\n  const fromTemporalClauses = temporalPredicateClauses(\n    params.from,\n    fromVariable,\n    fromTemporalArgs,\n    'from'\n  );\n  const toTemporalClauses = temporalPredicateClauses(\n    params.to,\n    toVariable,\n    toTemporalArgs,\n    'to'\n  );\n  // TODO cleaner semantics: remove use of _ prefixes in root variableNames and variableName\n  const [subQuery, subParams] = buildCypherSelection({\n    initial: '',\n    selections,\n    variableName,\n    schemaType,\n    resolveInfo,\n    paramIndex: 1,\n    parentSelectionInfo: {\n      rootType: 'relationship',\n      from: `_${fromVar}`,\n      to: `_${toVar}`\n    },\n    variableName: schemaType.name === fromType ? `_${toVar}` : `_${fromVar}`\n  });\n  params = { ...params, ...subParams };\n  let query = `\n      MATCH (${fromVariable}:${fromLabel} ${\n    fromTemporalClauses && fromTemporalClauses.length > 0\n      ? // uses either a WHERE clause for managed type primary keys (temporal, etc.)\n        `) WHERE ${fromTemporalClauses.join(' AND ')} `\n      : // or a an internal matching clause for normal, scalar property primary keys\n        `{${fromParam}: $from.${fromParam}})`\n  }\n      MATCH (${toVariable}:${toLabel} ${\n    toTemporalClauses && toTemporalClauses.length > 0\n      ? `) WHERE ${toTemporalClauses.join(' AND ')} `\n      : `{${toParam}: $to.${toParam}})`\n  }\n      OPTIONAL MATCH (${fromVariable})-[${relationshipVariable}:${relationshipLabel}]->(${toVariable})\n      DELETE ${relationshipVariable}\n      WITH COUNT(*) AS scope, ${fromVariable} AS ${fromRootVariable}, ${toVariable} AS ${toRootVariable}\n      RETURN {${subQuery}} AS ${schemaTypeName};\n    `;\n  return [query, params];\n};\n\nconst temporalTypeSelections = (selections, innerSchemaType) => {\n  // TODO use extractSelections instead?\n  const selectedTypes =\n    selections && selections[0] && selections[0].selectionSet\n      ? selections[0].selectionSet.selections\n      : [];\n  return selectedTypes\n    .reduce((temporalTypeFields, innerSelection) => {\n      // name of temporal type field\n      const fieldName = innerSelection.name.value;\n      const fieldTypeName = getFieldTypeName(innerSchemaType, fieldName);\n      if (isTemporalType(fieldTypeName)) {\n        const innerSelectedTypes = innerSelection.selectionSet\n          ? innerSelection.selectionSet.selections\n          : [];\n        temporalTypeFields.push(\n          `${fieldName}: {${innerSelectedTypes\n            .reduce((temporalSubFields, t) => {\n              // temporal type subfields, year, minute, etc.\n              const subFieldName = t.name.value;\n              if (subFieldName === 'formatted') {\n                temporalSubFields.push(\n                  `${subFieldName}: toString(sortedElement.${fieldName})`\n                );\n              } else {\n                temporalSubFields.push(\n                  `${subFieldName}: sortedElement.${fieldName}.${subFieldName}`\n                );\n              }\n              return temporalSubFields;\n            }, [])\n            .join(',')}}`\n        );\n      }\n      return temporalTypeFields;\n    }, [])\n    .join(',');\n};\n\nconst getFieldTypeName = (schemaType, fieldName) => {\n  // TODO handle for fragments?\n  const field =\n    schemaType && fieldName ? schemaType.getFields()[fieldName] : undefined;\n  return field ? field.type.name : '';\n};\n\nconst temporalOrderingFieldExists = (schemaType, filterParams) => {\n  let orderByParam = filterParams ? filterParams['orderBy'] : undefined;\n  if (orderByParam) {\n    orderByParam = orderByParam.value;\n    if (!Array.isArray(orderByParam)) orderByParam = [orderByParam];\n    return orderByParam.find(e => {\n      const fieldName = e.substring(0, e.indexOf('_'));\n      const fieldTypeName = getFieldTypeName(schemaType, fieldName);\n      return isTemporalType(fieldTypeName);\n    });\n  }\n  return undefined;\n};\n\nconst buildSortMultiArgs = param => {\n  let values = param ? param.value : [];\n  let fieldName = '';\n  if (!Array.isArray(values)) values = [values];\n  return values\n    .map(e => {\n      fieldName = e.substring(0, e.indexOf('_'));\n      return e.includes('_asc') ? `'^${fieldName}'` : `'${fieldName}'`;\n    })\n    .join(',');\n};\n"]}