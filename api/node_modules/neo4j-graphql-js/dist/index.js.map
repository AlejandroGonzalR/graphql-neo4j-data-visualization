{"version":3,"sources":["../src/index.js"],"names":["object","params","context","resolveInfo","debug","Error","query","cypherParams","cypherFunction","cypherMutation","cypherQuery","console","log","session","driver","result","writeTransaction","tx","run","readTransaction","close","returnType","neo4jgraphql","first","offset","_id","orderBy","otherParams","typeName","variableName","schemaType","schema","getType","selections","augmentSchema","config","mutation","temporal","typeMap","resolvers","makeAugmentedSchema","typeDefs","logger","allowUndefinedInResolve","resolverValidationOptions","directiveResolvers","schemaDirectives","parseOptions","inheritResolversFromInterfaces","augmentTypeDefs"],"mappings":"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","file":"index.js","sourcesContent":["import {\n  extractQueryResult,\n  isMutation,\n  typeIdentifiers,\n  extractTypeMapFromTypeDefs,\n  addDirectiveDeclarations,\n  printTypeMap,\n  getPayloadSelections\n} from './utils';\nimport {\n  extractTypeMapFromSchema,\n  extractResolversFromSchema,\n  augmentedSchema,\n  makeAugmentedExecutableSchema,\n  addTemporalTypes\n} from './augment';\nimport { checkRequestError } from './auth';\nimport { translateMutation, translateQuery } from './translate';\n\nexport async function neo4jgraphql(\n  object,\n  params,\n  context,\n  resolveInfo,\n  debug = true\n) {\n  // throw error if context.req.error exists\n  if (checkRequestError(context)) {\n    throw new Error(checkRequestError(context));\n  }\n\n  let query;\n  let cypherParams;\n\n  const cypherFunction = isMutation(resolveInfo) ? cypherMutation : cypherQuery;\n  [query, cypherParams] = cypherFunction(params, context, resolveInfo);\n\n  if (debug) {\n    console.log(query);\n    console.log(cypherParams);\n  }\n\n  const session = context.driver.session();\n  let result;\n\n  try {\n    if (isMutation(resolveInfo)) {\n      result = await session.writeTransaction(tx => {\n        return tx.run(query, cypherParams);\n      });\n    } else {\n      result = await session.readTransaction(tx => {\n        return tx.run(query, cypherParams);\n      });\n    }\n  } finally {\n    session.close();\n  }\n  return extractQueryResult(result, resolveInfo.returnType);\n}\n\nexport function cypherQuery(\n  { first = -1, offset = 0, _id, orderBy, ...otherParams },\n  context,\n  resolveInfo\n) {\n  const { typeName, variableName } = typeIdentifiers(resolveInfo.returnType);\n  const schemaType = resolveInfo.schema.getType(typeName);\n  const selections = getPayloadSelections(resolveInfo);\n  return translateQuery({\n    resolveInfo,\n    context,\n    schemaType,\n    selections,\n    variableName,\n    typeName,\n    first,\n    offset,\n    _id,\n    orderBy,\n    otherParams\n  });\n}\n\nexport function cypherMutation(\n  { first = -1, offset = 0, _id, orderBy, ...otherParams },\n  context,\n  resolveInfo\n) {\n  const { typeName, variableName } = typeIdentifiers(resolveInfo.returnType);\n  const schemaType = resolveInfo.schema.getType(typeName);\n  const selections = getPayloadSelections(resolveInfo);\n  return translateMutation({\n    resolveInfo,\n    context,\n    schemaType,\n    selections,\n    variableName,\n    typeName,\n    first,\n    offset,\n    otherParams\n  });\n}\n\nexport const augmentSchema = (\n  schema,\n  config = {\n    query: true,\n    mutation: true,\n    temporal: true,\n    debug: true\n  }\n) => {\n  const typeMap = extractTypeMapFromSchema(schema);\n  const resolvers = extractResolversFromSchema(schema);\n  return augmentedSchema(typeMap, resolvers, config);\n};\n\nexport const makeAugmentedSchema = ({\n  schema,\n  typeDefs,\n  resolvers = {},\n  logger,\n  allowUndefinedInResolve = false,\n  resolverValidationOptions = {},\n  directiveResolvers = null,\n  schemaDirectives = null,\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n  config = {\n    query: true,\n    mutation: true,\n    temporal: true,\n    debug: true\n  }\n}) => {\n  if (schema) {\n    return augmentSchema(schema, config);\n  }\n  if (!typeDefs) throw new Error('Must provide typeDefs');\n  return makeAugmentedExecutableSchema({\n    typeDefs,\n    resolvers,\n    logger,\n    allowUndefinedInResolve,\n    resolverValidationOptions,\n    directiveResolvers,\n    schemaDirectives,\n    parseOptions,\n    inheritResolversFromInterfaces,\n    config\n  });\n};\n\nexport const augmentTypeDefs = (typeDefs, config) => {\n  let typeMap = extractTypeMapFromTypeDefs(typeDefs);\n  // overwrites any provided declarations of system directives\n  typeMap = addDirectiveDeclarations(typeMap);\n  // adds managed types; tepmoral, spatial, etc.\n  typeMap = addTemporalTypes(typeMap, config);\n  return printTypeMap(typeMap);\n};\n"]}