{"version":3,"sources":["../src/augment.js"],"names":["augmentedSchema","typeMap","resolvers","config","augmentedTypeMap","augmentTypeMap","augmentedResolvers","augmentResolvers","typeDefs","resolverValidationOptions","requireResolversForResolveType","makeAugmentedExecutableSchema","logger","allowUndefinedInResolve","directiveResolvers","schemaDirectives","parseOptions","inheritResolversFromInterfaces","extractTypeMapFromSchema","schema","getTypeMap","directives","getDirectives","types","astNode","reduce","acc","t","undefined","name","value","extractResolversFromSchema","_typeMap","type","schemaTypeResolvers","extractFieldResolversFromSchemaType","fields","_fields","fieldKeys","fieldResolvers","length","resolve","rootTypes","query","mutation","initializeOperationTypes","addRelationTypeDirectives","addTemporalTypes","forEach","augmentType","possiblyAddQuery","possiblyAddOrderingEnum","possiblyAddTypeInput","possiblyAddTypeMutations","handleRelationFields","augmentQueryArguments","queryResolvers","Query","generatedQueryMap","possiblyAddResolvers","mutationResolvers","Mutation","generatedMutationMap","interfaceTypes","filter","e","kind","map","obj","context","info","possiblyAddOrderingArgument","args","fieldName","orderingType","findIndex","push","possiblyAddArgument","fieldType","queryType","shouldAugmentType","addOrReplaceNodeIdField","possiblyAddTypeFieldArguments","queryMap","valueTypeName","valueType","field","queryNames","arguments","operationTypeMap","operationName","neo4jgraphql","debug","typeName","inputName","pk","nodeInputType","decideFieldType","hasSomePropertyField","find","fromField","fromName","toField","toName","shouldAugmentRelationField","relationInputFields","buildRelationTypeInputFields","createQueryArguments","values","createOrderingFields","mutationMap","possiblyAddTypeMutation","relationTypeName","relationType","fieldIsNotIgnored","possiblyAddObjectType","interfaces","namePrefix","mutationName","buildMutationArguments","possiblyAddRelationTypeFieldPayload","relationAstNode","capitalizedFieldName","fieldTypeName","fieldValueName","_fromField","_toField","fromValue","toValue","relationTypeDirective","relationTypePayloadFields","join","fieldIsList","fieldArgs","getFieldArgumentsFromAst","possiblyAddRelationMutationField","relationName","relatedAstNode","relationHasProps","mutationTypes","payloadTypeName","action","shouldUseRelationDataArgument","validateRelationTypeDirectedFields","Error","fieldCount","relationFieldDirective","fieldIndex","charAt","toUpperCase","substr","handleRelationFieldDirective","handleRelationTypeDirective","typeDirectiveArgs","nameArgument","fromArgument","toArgument","replaceRelationTypeValue","direction","temp","isList","index","definition","splice","to","from","fromTypeName","toTypeName","typeDirective","typeDirectiveIndex","transformRelationName","nameArg","valueKind","queryArg","hasNonExcludedNodeType","rootType","mutationType","char","uppercased","temporalTypes","time","definitions","date","datetime","localtime","localdatetime","transformTemporalFieldArgs","arg","transformTemporalTypeName","transformTemporalFields","isArgument","decideTemporalConfig","defaultConfig","providedConfig","temporal","isNotSystemField","paginationArgs","primaryKey","buildCreateMutationArguments","buildUpdateMutationArguments","buildDeleteMutationArguments","primaryKeyName","primaryKeyType","parsedPrimaryKeyField","mutationArgs","unshift","transformManagedFieldTypes","firstIdField","includes","replace"],"mappings":"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","file":"augment.js","sourcesContent":["import { makeExecutableSchema } from 'graphql-tools';\nimport { parse, print } from 'graphql';\nimport { neo4jgraphql } from './index';\nimport {\n  printTypeMap,\n  extractTypeMapFromTypeDefs,\n  createOperationMap,\n  addDirectiveDeclarations,\n  getNamedType,\n  getPrimaryKey,\n  getFieldDirective,\n  getRelationTypeDirectiveArgs,\n  getRelationMutationPayloadFieldsFromAst,\n  getRelationDirection,\n  getRelationName,\n  getTypeDirective,\n  isBasicScalar,\n  isListType,\n  isKind,\n  isNonNullType,\n  isNodeType,\n  parseFieldSdl,\n  parseDirectiveSdl,\n  isTemporalType,\n  excludeIgnoredTypes,\n  getCustomFieldResolver,\n  possiblyAddIgnoreDirective,\n  getExcludedTypes,\n  parseInputFieldsSdl\n} from './utils';\n\nexport const augmentedSchema = (typeMap, resolvers, config) => {\n  const augmentedTypeMap = augmentTypeMap(typeMap, resolvers, config);\n  const augmentedResolvers = augmentResolvers(\n    augmentedTypeMap,\n    resolvers,\n    config\n  );\n  return makeExecutableSchema({\n    typeDefs: printTypeMap(augmentedTypeMap),\n    resolvers: augmentedResolvers,\n    resolverValidationOptions: {\n      requireResolversForResolveType: false\n    }\n  });\n};\n\nexport const makeAugmentedExecutableSchema = ({\n  typeDefs,\n  resolvers,\n  logger,\n  allowUndefinedInResolve,\n  resolverValidationOptions,\n  directiveResolvers,\n  schemaDirectives,\n  parseOptions,\n  inheritResolversFromInterfaces,\n  config\n}) => {\n  const typeMap = extractTypeMapFromTypeDefs(typeDefs);\n  const augmentedTypeMap = augmentTypeMap(typeMap, resolvers, config);\n  const augmentedResolvers = augmentResolvers(\n    augmentedTypeMap,\n    resolvers,\n    config\n  );\n  resolverValidationOptions.requireResolversForResolveType = false;\n  return makeExecutableSchema({\n    typeDefs: printTypeMap(augmentedTypeMap),\n    resolvers: augmentedResolvers,\n    logger: logger,\n    allowUndefinedInResolve: allowUndefinedInResolve,\n    resolverValidationOptions: resolverValidationOptions,\n    directiveResolvers: directiveResolvers,\n    schemaDirectives: schemaDirectives,\n    parseOptions: parseOptions,\n    inheritResolversFromInterfaces: inheritResolversFromInterfaces\n  });\n};\n\nexport const extractTypeMapFromSchema = schema => {\n  const typeMap = schema.getTypeMap();\n  const directives = schema.getDirectives();\n  const types = { ...typeMap, ...directives };\n  let astNode = {};\n  return Object.keys(types).reduce((acc, t) => {\n    astNode = types[t].astNode;\n    if (astNode !== undefined) {\n      acc[astNode.name.value] = astNode;\n    }\n    return acc;\n  }, {});\n};\n\nexport const extractResolversFromSchema = schema => {\n  const _typeMap = schema && schema._typeMap ? schema._typeMap : {};\n  const types = Object.keys(_typeMap);\n  let type = {};\n  let schemaTypeResolvers = {};\n  return types.reduce((acc, t) => {\n    // prevent extraction from schema introspection system keys\n    if (\n      t !== '__Schema' &&\n      t !== '__Type' &&\n      t !== '__TypeKind' &&\n      t !== '__Field' &&\n      t !== '__InputValue' &&\n      t !== '__EnumValue' &&\n      t !== '__Directive'\n    ) {\n      type = _typeMap[t];\n      // resolvers are stored on the field level at a .resolve key\n      schemaTypeResolvers = extractFieldResolversFromSchemaType(type);\n      // do not add unless there exists at least one field resolver for type\n      if (schemaTypeResolvers) {\n        acc[t] = schemaTypeResolvers;\n      }\n    }\n    return acc;\n  }, {});\n};\n\nconst extractFieldResolversFromSchemaType = type => {\n  const fields = type._fields;\n  const fieldKeys = fields ? Object.keys(fields) : [];\n  const fieldResolvers =\n    fieldKeys.length > 0\n      ? fieldKeys.reduce((acc, t) => {\n          // do not add entry for this field unless it has resolver\n          if (fields[t].resolve !== undefined) {\n            acc[t] = fields[t].resolve;\n          }\n          return acc;\n        }, {})\n      : undefined;\n  // do not return value unless there exists at least 1 field resolver\n  return fieldResolvers && Object.keys(fieldResolvers).length > 0\n    ? fieldResolvers\n    : undefined;\n};\n\nexport const augmentTypeMap = (typeMap, resolvers, config) => {\n  // IDEA: elevate into config as config.rootTypes?\n  const rootTypes = {\n    query: 'Query',\n    mutation: 'Mutation'\n  };\n  config = excludeIgnoredTypes(typeMap, config);\n  typeMap = initializeOperationTypes(typeMap, rootTypes, config);\n  typeMap = addRelationTypeDirectives(typeMap);\n  typeMap = addTemporalTypes(typeMap, config);\n  Object.entries(typeMap).forEach(([name, type]) => {\n    if (!isTemporalType(name)) {\n      typeMap[name] = augmentType(type, typeMap, resolvers, rootTypes, config);\n      typeMap = possiblyAddQuery(type, typeMap, resolvers, rootTypes, config);\n      typeMap = possiblyAddOrderingEnum(type, typeMap, resolvers, config);\n      typeMap = possiblyAddTypeInput(type, typeMap, resolvers, config);\n      typeMap = possiblyAddTypeMutations(type, typeMap, resolvers, config);\n      typeMap = handleRelationFields(type, typeMap, resolvers, config);\n    }\n  });\n  typeMap = augmentQueryArguments(typeMap, config, rootTypes);\n  typeMap = addDirectiveDeclarations(typeMap);\n  return typeMap;\n};\n\nconst augmentResolvers = (augmentedTypeMap, resolvers, config) => {\n  let queryResolvers = resolvers && resolvers.Query ? resolvers.Query : {};\n  const generatedQueryMap = createOperationMap(augmentedTypeMap.Query);\n  queryResolvers = possiblyAddResolvers(\n    generatedQueryMap,\n    queryResolvers,\n    config\n  );\n  if (Object.keys(queryResolvers).length > 0) {\n    resolvers.Query = queryResolvers;\n  }\n  let mutationResolvers =\n    resolvers && resolvers.Mutation ? resolvers.Mutation : {};\n  const generatedMutationMap = createOperationMap(augmentedTypeMap.Mutation);\n  mutationResolvers = possiblyAddResolvers(\n    generatedMutationMap,\n    mutationResolvers,\n    config\n  );\n  if (Object.keys(mutationResolvers).length > 0) {\n    resolvers.Mutation = mutationResolvers;\n  }\n  // must implement __resolveInfo for every Interface type\n  // we use \"FRAGMENT_TYPE\" key to identify the Interface implementation\n  // type at runtime, so grab this value\n  const interfaceTypes = Object.keys(augmentedTypeMap).filter(\n    e => augmentedTypeMap[e].kind === 'InterfaceTypeDefinition'\n  );\n  interfaceTypes.map(e => {\n    resolvers[e] = {};\n\n    resolvers[e]['__resolveType'] = (obj, context, info) => {\n      return obj['FRAGMENT_TYPE'];\n    };\n  });\n\n  return resolvers;\n};\n\nconst possiblyAddOrderingArgument = (args, fieldName) => {\n  const orderingType = `_${fieldName}Ordering`;\n  if (args.findIndex(e => e.name.value === orderingType) === -1) {\n    args.push({\n      kind: 'InputValueDefinition',\n      name: {\n        kind: 'Name',\n        value: 'orderBy'\n      },\n      type: {\n        kind: 'ListType',\n        type: {\n          kind: 'NamedType',\n          name: {\n            kind: 'Name',\n            value: orderingType\n          }\n        }\n      }\n    });\n  }\n  return args;\n};\n\nexport const possiblyAddArgument = (args, fieldName, fieldType) => {\n  if (args.findIndex(e => e.name.value === fieldName) === -1) {\n    args.push({\n      kind: 'InputValueDefinition',\n      name: {\n        kind: 'Name',\n        value: fieldName\n      },\n      type: {\n        kind: 'NamedType',\n        name: {\n          kind: 'Name',\n          value: fieldType\n        }\n      }\n    });\n  }\n  return args;\n};\n\nconst augmentType = (astNode, typeMap, resolvers, rootTypes, config) => {\n  const queryType = rootTypes.query;\n  if (isNodeType(astNode)) {\n    if (shouldAugmentType(config, 'query', astNode.name.value)) {\n      // Only add _id field to type if query API is generated for type\n      astNode.fields = addOrReplaceNodeIdField(astNode, resolvers);\n    }\n    astNode.fields = possiblyAddTypeFieldArguments(\n      astNode,\n      typeMap,\n      resolvers,\n      config,\n      queryType\n    );\n  }\n  // FIXME: inferring where to add @neo4j_ignore directive improperly causes\n  //        fields to be ignored when logger is added, so remove functionality\n  //        until we refactor how to infer when @neo4j_ignore directive is needed\n  //        see https://github.com/neo4j-graphql/neo4j-graphql-js/issues/189\n  // astNode.fields = possiblyAddIgnoreDirective(\n  //   astNode,\n  //   typeMap,\n  //   resolvers,\n  //   config\n  // );\n  return astNode;\n};\n\nconst augmentQueryArguments = (typeMap, config, rootTypes) => {\n  const queryType = rootTypes.query;\n  // adds first / offset / orderBy to queries returning node type lists\n  const queryMap = createOperationMap(typeMap.Query);\n  let args = [];\n  let valueTypeName = '';\n  let valueType = {};\n  let field = {};\n  let queryNames = Object.keys(queryMap);\n  if (queryNames.length > 0) {\n    queryNames.forEach(t => {\n      field = queryMap[t];\n      valueTypeName = getNamedType(field).name.value;\n      valueType = typeMap[valueTypeName];\n      if (\n        isNodeType(valueType) &&\n        isListType(field) &&\n        shouldAugmentType(config, 'query', valueTypeName)\n      ) {\n        // does not add arguments if the field value type is excluded\n        args = field.arguments;\n        queryMap[t].arguments = possiblyAddArgument(args, 'first', 'Int');\n        queryMap[t].arguments = possiblyAddArgument(args, 'offset', 'Int');\n        queryMap[t].arguments = possiblyAddOrderingArgument(\n          args,\n          valueTypeName\n        );\n      }\n    });\n    typeMap[queryType].fields = Object.values(queryMap);\n  }\n  return typeMap;\n};\n\nconst possiblyAddResolvers = (operationTypeMap, resolvers, config) => {\n  let operationName = '';\n  return Object.keys(operationTypeMap).reduce((acc, t) => {\n    // if no resolver provided for this operation type field\n    operationName = operationTypeMap[t].name.value;\n    if (acc[operationName] === undefined) {\n      acc[operationName] = function(...args) {\n        return neo4jgraphql(...args, config.debug);\n      };\n    }\n    return acc;\n  }, resolvers);\n};\n\nconst possiblyAddTypeInput = (astNode, typeMap, resolvers, config) => {\n  const typeName = astNode.name.value;\n  if (shouldAugmentType(config, 'mutation', typeName)) {\n    const inputName = `_${astNode.name.value}Input`;\n    if (isNodeType(astNode)) {\n      if (typeMap[inputName] === undefined) {\n        const pk = getPrimaryKey(astNode);\n        if (pk) {\n          const nodeInputType = `\n            input ${inputName} { ${pk.name.value}: ${\n            // Always exactly require the pk of a node type\n            decideFieldType(getNamedType(pk).name.value)\n          }! }`;\n          typeMap[inputName] = parse(nodeInputType);\n        }\n      }\n    } else if (getTypeDirective(astNode, 'relation')) {\n      // Only used for the .data argument in generated relation creation mutations\n      if (typeMap[inputName] === undefined) {\n        const fields = astNode.fields;\n        // The .data arg on add relation mutations,\n        // which is the only arg in the API that uses\n        // relation input types, is only generate if there\n        // is at least one non-directed field (property field)\n        const hasSomePropertyField = fields.find(\n          e => e.name.value !== 'from' && e.name.value !== 'to'\n        );\n        const fromField = fields.find(e => e.name.value === 'from');\n        const fromName = getNamedType(fromField).name.value;\n        const toField = fields.find(e => e.name.value === 'to');\n        const toName = getNamedType(toField).name.value;\n        // only generate an input type for the relationship if we know that both\n        // the from and to nodes are not excluded, since thus we know that\n        // relation mutations are generated for this relation, which would\n        // make use of the relation input type\n        if (\n          hasSomePropertyField &&\n          shouldAugmentRelationField(config, 'mutation', fromName, toName)\n        ) {\n          const relationInputFields = buildRelationTypeInputFields(\n            astNode,\n            fields,\n            typeMap,\n            resolvers\n          );\n          typeMap[inputName] = parse(\n            `input ${inputName} {${relationInputFields}}`\n          );\n        }\n      }\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddQuery = (astNode, typeMap, resolvers, rootTypes, config) => {\n  const typeName = astNode.name.value;\n  const queryType = rootTypes.query;\n  const queryMap = createOperationMap(typeMap.Query);\n  if (isNodeType(astNode) && shouldAugmentType(config, 'query', typeName)) {\n    const name = astNode.name.value;\n    if (queryMap[name] === undefined) {\n      typeMap[queryType].fields.push({\n        kind: 'FieldDefinition',\n        name: {\n          kind: 'Name',\n          value: name\n        },\n        arguments: createQueryArguments(astNode, resolvers, typeMap),\n        type: {\n          kind: 'ListType',\n          type: {\n            kind: 'NamedType',\n            name: {\n              kind: 'Name',\n              value: name\n            }\n          }\n        }\n      });\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddOrderingEnum = (astNode, typeMap, resolvers, config) => {\n  const typeName = astNode.name.value;\n  if (isNodeType(astNode) && shouldAugmentType(config, 'query', typeName)) {\n    const name = `_${astNode.name.value}Ordering`;\n    const values = createOrderingFields(astNode, typeMap, resolvers);\n    // Add ordering enum if it does not exist already and if\n    // there is at least one basic scalar field on this type\n    if (typeMap[name] === undefined && values.length > 0) {\n      typeMap[name] = {\n        kind: 'EnumTypeDefinition',\n        name: {\n          kind: 'Name',\n          value: name\n        },\n        directives: [],\n        values: values\n      };\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddTypeMutations = (astNode, typeMap, resolvers, config) => {\n  const typeName = astNode.name.value;\n  if (shouldAugmentType(config, 'mutation', typeName)) {\n    const mutationMap = createOperationMap(typeMap.Mutation);\n    if (\n      isNodeType(astNode) &&\n      shouldAugmentType(config, 'mutation', typeName)\n    ) {\n      typeMap = possiblyAddTypeMutation(\n        `Create`,\n        astNode,\n        resolvers,\n        typeMap,\n        mutationMap\n      );\n      typeMap = possiblyAddTypeMutation(\n        `Update`,\n        astNode,\n        resolvers,\n        typeMap,\n        mutationMap\n      );\n      typeMap = possiblyAddTypeMutation(\n        `Delete`,\n        astNode,\n        resolvers,\n        typeMap,\n        mutationMap\n      );\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddTypeFieldArguments = (\n  astNode,\n  typeMap,\n  resolvers,\n  config,\n  queryType\n) => {\n  const fields = astNode.fields;\n  let relationTypeName = '';\n  let relationType = {};\n  let args = [];\n  fields.forEach(field => {\n    relationTypeName = getNamedType(field).name.value;\n    relationType = typeMap[relationTypeName];\n    if (\n      fieldIsNotIgnored(astNode, field, resolvers) &&\n      // only adds args if node payload type has not been excluded\n      shouldAugmentType(config, 'query', relationTypeName) &&\n      // we know astNode is a node type, so this field should be a node type\n      // as well, since the generated args are only for node type lists\n      isNodeType(relationType) &&\n      // the args (first / offset / orderBy) are only generated for list fields\n      isListType(field) &&\n      (getFieldDirective(field, 'relation') ||\n        getFieldDirective(field, 'cypher'))\n    ) {\n      args = field.arguments;\n      field.arguments = possiblyAddArgument(args, 'first', 'Int');\n      field.arguments = possiblyAddArgument(args, 'offset', 'Int');\n      field.arguments = possiblyAddOrderingArgument(args, relationTypeName);\n    }\n  });\n  return fields;\n};\n\nconst possiblyAddObjectType = (typeMap, name) => {\n  if (typeMap[name] === undefined) {\n    typeMap[name] = {\n      kind: 'ObjectTypeDefinition',\n      name: {\n        kind: 'Name',\n        value: name\n      },\n      interfaces: [],\n      directives: [],\n      fields: []\n    };\n  }\n  return typeMap;\n};\n\nconst possiblyAddTypeMutation = (\n  namePrefix,\n  astNode,\n  resolvers,\n  typeMap,\n  mutationMap\n) => {\n  const typeName = astNode.name.value;\n  const mutationName = namePrefix + typeName;\n  // Only generate if the mutation named mutationName does not already exist\n  if (mutationMap[mutationName] === undefined) {\n    const args = buildMutationArguments(\n      namePrefix,\n      astNode,\n      resolvers,\n      typeMap\n    );\n    if (args.length > 0) {\n      typeMap['Mutation'].fields.push({\n        kind: 'FieldDefinition',\n        name: {\n          kind: 'Name',\n          value: mutationName\n        },\n        arguments: args,\n        type: {\n          kind: 'NamedType',\n          name: {\n            kind: 'Name',\n            value: typeName\n          }\n        },\n        directives: []\n      });\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddRelationTypeFieldPayload = (\n  relationAstNode,\n  capitalizedFieldName,\n  typeName,\n  typeMap,\n  field\n) => {\n  const fieldTypeName = `_${typeName}${capitalizedFieldName}`;\n  if (!typeMap[fieldTypeName]) {\n    let fieldName = '';\n    let fieldValueName = '';\n    let fromField = {};\n    let toField = {};\n    let _fromField = {};\n    let _toField = {};\n    let fromValue = undefined;\n    let toValue = undefined;\n    let fields = relationAstNode.fields;\n    const relationTypeDirective = getRelationTypeDirectiveArgs(relationAstNode);\n    if (relationTypeDirective) {\n      // TODO refactor\n      const relationTypePayloadFields = fields\n        .reduce((acc, t) => {\n          fieldValueName = getNamedType(t).name.value;\n          fieldName = t.name.value;\n          if (fieldName === 'from') {\n            fromValue = fieldValueName;\n            fromField = t;\n          } else if (fieldName === 'to') {\n            toValue = fieldValueName;\n            toField = t;\n          } else {\n            // Exclude .to and .from, but gather them from along the way\n            // using previous branches above\n            acc.push(print(t));\n          }\n          return acc;\n        }, [])\n        .join('\\n');\n\n      if (fromValue && fromValue === toValue) {\n        // If field is a list type, then make .from and .to list types\n        const fieldIsList = isListType(field);\n        const fieldArgs = getFieldArgumentsFromAst(field, typeName);\n        typeMap[`${fieldTypeName}Directions`] = parse(`\n        type ${fieldTypeName}Directions ${print(relationAstNode.directives)} {\n            from${fieldArgs}: ${fieldIsList ? '[' : ''}${fieldTypeName}${\n          fieldIsList ? ']' : ''\n        }\n            to${fieldArgs}: ${fieldIsList ? '[' : ''}${fieldTypeName}${\n          fieldIsList ? ']' : ''\n        }\n      }`);\n\n        typeMap[fieldTypeName] = parse(`\n      type ${fieldTypeName} ${print(relationAstNode.directives)} {\n        ${relationTypePayloadFields}\n        ${fromValue}: ${fromValue}\n      }\n      `);\n\n        // remove arguments on field\n        field.arguments = [];\n      } else {\n        // Non-reflexive case, (User)-[RATED]->(Movie)\n        typeMap[fieldTypeName] = parse(`\n      type ${fieldTypeName} ${print(relationAstNode.directives)} {\n        ${relationTypePayloadFields}\n        ${\n          typeName === toValue\n            ? // If this is the from, the allow selecting the to\n              `${fromValue}: ${fromValue}`\n            : // else this is the to, so allow selecting the from\n            typeName === fromValue\n            ? `${toValue}: ${toValue}`\n            : ''\n        }\n      }\n      `);\n      }\n    }\n  }\n  return typeMap;\n};\n\nconst possiblyAddRelationMutationField = (\n  typeName,\n  capitalizedFieldName,\n  fromName,\n  toName,\n  mutationMap,\n  typeMap,\n  relationName,\n  relatedAstNode,\n  relationHasProps\n) => {\n  const mutationTypes = ['Add', 'Remove'];\n  let mutationName = '';\n  let payloadTypeName = '';\n  let hasSomePropertyField = false;\n  mutationTypes.forEach(action => {\n    mutationName = `${action}${typeName}${capitalizedFieldName}`;\n    // Prevents overwriting\n    if (mutationMap[mutationName] === undefined) {\n      payloadTypeName = `_${mutationName}Payload`;\n      hasSomePropertyField = relatedAstNode.fields.find(\n        e => e.name.value !== 'from' && e.name.value !== 'to'\n      );\n      // If we know we should expect data properties (from context: relationHasProps)\n      // and if there is at least 1 field that is not .to or .from (hasSomePropertyField)\n      // and if we are generating the add relation mutation, then add the .data argument\n      const shouldUseRelationDataArgument =\n        relationHasProps && hasSomePropertyField && action === 'Add';\n      // Relation mutation type\n      typeMap.Mutation.fields.push(\n        parseFieldSdl(`\n          ${mutationName}(from: _${fromName}Input!, to: _${toName}Input!${\n          shouldUseRelationDataArgument\n            ? `, data: _${relatedAstNode.name.value}Input!`\n            : ''\n        }): ${payloadTypeName} @MutationMeta(relationship: \"${relationName}\", from: \"${fromName}\", to: \"${toName}\")\n      `)\n      );\n      // Prevents overwriting\n      if (typeMap[payloadTypeName] === undefined) {\n        typeMap[payloadTypeName] = parse(`\n        type ${payloadTypeName} @relation(name: \"${relationName}\", from: \"${fromName}\", to: \"${toName}\") {\n          from: ${fromName}\n          to: ${toName}\n          ${\n            shouldUseRelationDataArgument\n              ? getRelationMutationPayloadFieldsFromAst(relatedAstNode)\n              : ''\n          }\n        }\n        `);\n      }\n    }\n  });\n  return typeMap;\n};\n\nconst decideFieldType = name => {\n  if (isTemporalType(name)) {\n    name = `${name}Input`;\n  }\n  return name;\n};\n\nconst validateRelationTypeDirectedFields = (typeName, fromName, toName) => {\n  // directive to and from are not the same and neither are equal to this\n  if (fromName !== toName && toName !== typeName && fromName !== typeName) {\n    throw new Error(`The '${\n      field.name.value\n    }' field on the '${typeName}' type uses the '${relatedAstNode.name.value}'\n    but '${\n      relatedAstNode.name.value\n    }' comes from '${fromName}' and goes to '${toName}'`);\n  }\n  return true;\n};\n\nconst handleRelationFields = (astNode, typeMap, resolvers, config) => {\n  const mutationMap = createOperationMap(typeMap.Mutation);\n  const typeName = astNode.name.value;\n  const fields = astNode.fields;\n  const fieldCount = fields ? fields.length : 0;\n  let relationFieldDirective = {};\n  let fieldValueName = '';\n  let relatedAstNode = {};\n  let relationTypeDirective = {};\n  let capitalizedFieldName = '';\n  let field = {};\n  let fieldIndex = 0;\n  if (isNodeType(astNode)) {\n    for (; fieldIndex < fieldCount; ++fieldIndex) {\n      field = fields[fieldIndex];\n      if (fieldIsNotIgnored(astNode, field, resolvers)) {\n        fieldValueName = getNamedType(field).name.value;\n        capitalizedFieldName =\n          field.name.value.charAt(0).toUpperCase() + field.name.value.substr(1);\n        relatedAstNode = typeMap[fieldValueName];\n        if (relatedAstNode) {\n          relationTypeDirective = getTypeDirective(relatedAstNode, 'relation');\n          relationFieldDirective = getFieldDirective(field, 'relation');\n          // continue if typeName is allowed\n          // in either Query or Mutation\n          if (isNodeType(relatedAstNode)) {\n            // the field has a node type\n            if (relationFieldDirective) {\n              // Relation Mutation API\n              // relation directive exists on field\n              typeMap = handleRelationFieldDirective({\n                relatedAstNode,\n                typeName,\n                capitalizedFieldName,\n                fieldValueName,\n                relationFieldDirective,\n                mutationMap,\n                typeMap,\n                config\n              });\n            }\n          } else if (relationTypeDirective) {\n            // Query and Relation Mutation API\n            // the field value is a non-node type using a relation type directive\n            typeMap = handleRelationTypeDirective({\n              relatedAstNode,\n              typeName,\n              fields,\n              field,\n              fieldIndex,\n              capitalizedFieldName,\n              relationTypeDirective,\n              config,\n              typeMap,\n              mutationMap\n            });\n          }\n        }\n      }\n    }\n  }\n  return typeMap;\n};\n\nconst handleRelationTypeDirective = ({\n  relatedAstNode,\n  typeName,\n  fields,\n  field,\n  fieldIndex,\n  capitalizedFieldName,\n  relationTypeDirective,\n  config,\n  typeMap,\n  mutationMap\n}) => {\n  const typeDirectiveArgs = relationTypeDirective\n    ? relationTypeDirective.arguments\n    : [];\n  const nameArgument = typeDirectiveArgs.find(e => e.name.value === 'name');\n  const fromArgument = typeDirectiveArgs.find(e => e.name.value === 'from');\n  const toArgument = typeDirectiveArgs.find(e => e.name.value === 'to');\n  const relationName = nameArgument.value.value;\n  const fromName = fromArgument.value.value;\n  const toName = toArgument.value.value;\n  // Relation Mutation API, adds relation mutation to Mutation\n  if (\n    shouldAugmentRelationField(config, 'mutation', fromName, toName) &&\n    validateRelationTypeDirectedFields(typeName, fromName, toName)\n  ) {\n    typeMap = possiblyAddRelationMutationField(\n      typeName,\n      capitalizedFieldName,\n      fromName,\n      toName,\n      mutationMap,\n      typeMap,\n      relationName,\n      relatedAstNode,\n      true\n    );\n  }\n  // Relation type field payload transformation for selection sets\n  typeMap = possiblyAddRelationTypeFieldPayload(\n    relatedAstNode,\n    capitalizedFieldName,\n    typeName,\n    typeMap,\n    field\n  );\n  // Replaces the field's value with the generated payload type\n  fields[fieldIndex] = replaceRelationTypeValue(\n    fromName,\n    toName,\n    field,\n    capitalizedFieldName,\n    typeName\n  );\n  return typeMap;\n};\n\nconst handleRelationFieldDirective = ({\n  relatedAstNode,\n  typeName,\n  capitalizedFieldName,\n  fieldValueName,\n  relationFieldDirective,\n  mutationMap,\n  typeMap,\n  config\n}) => {\n  let fromName = typeName;\n  let toName = fieldValueName;\n  // Mutation API, relation mutations for field directives\n  if (shouldAugmentRelationField(config, 'mutation', fromName, toName)) {\n    const relationName = getRelationName(relationFieldDirective);\n    const direction = getRelationDirection(relationFieldDirective);\n    // possibly swap directions to fit assertion of fromName = typeName\n    if (direction === 'IN' || direction === 'in') {\n      let temp = fromName;\n      fromName = toName;\n      toName = temp;\n    }\n    // (Mutation API) add relation mutation to Mutation\n    typeMap = possiblyAddRelationMutationField(\n      typeName,\n      capitalizedFieldName,\n      fromName,\n      toName,\n      mutationMap,\n      typeMap,\n      relationName,\n      relatedAstNode,\n      false\n    );\n  }\n  return typeMap;\n};\n\nconst replaceRelationTypeValue = (\n  fromName,\n  toName,\n  field,\n  capitalizedFieldName,\n  typeName\n) => {\n  const isList = isListType(field);\n  let type = {\n    kind: 'NamedType',\n    name: {\n      kind: 'Name',\n      value: `_${typeName}${capitalizedFieldName}${\n        fromName === toName ? 'Directions' : ''\n      }`\n    }\n  };\n  if (isList && fromName !== toName) {\n    type = {\n      kind: 'ListType',\n      type: type\n    };\n  }\n  field.type = type;\n  return field;\n};\n\nconst addOrReplaceNodeIdField = (astNode, resolvers) => {\n  const fields = astNode ? astNode.fields : [];\n  const index = fields.findIndex(e => e.name.value === '_id');\n  const definition = {\n    kind: 'FieldDefinition',\n    name: {\n      kind: 'Name',\n      value: '_id'\n    },\n    arguments: [],\n    type: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: 'String'\n      }\n    },\n    directives: []\n  };\n  if (index >= 0) {\n    if (fieldIsNotIgnored(astNode, fields[index], resolvers)) {\n      fields.splice(index, 1, definition);\n    }\n  } else {\n    fields.push(definition);\n  }\n  return fields;\n};\n\nconst addRelationTypeDirectives = typeMap => {\n  let astNode = {};\n  let fields = [];\n  let name = '';\n  let to = {};\n  let from = {};\n  let fromTypeName = '';\n  let toTypeName = '';\n  let typeDirective = {};\n  let relationName = '';\n  let typeDirectiveIndex = -1;\n  Object.keys(typeMap).forEach(typeName => {\n    astNode = typeMap[typeName];\n    name = astNode.name.value;\n    fields = astNode.fields;\n    to = fields ? fields.find(e => e.name.value === 'to') : undefined;\n    from = fields ? fields.find(e => e.name.value === 'from') : undefined;\n    if (to && !from) {\n      throw new Error(\n        `Relationship type ${name} has a 'to' field but no corresponding 'from' field`\n      );\n    }\n    if (from && !to) {\n      throw new Error(\n        `Relationship type ${name} has a 'from' field but no corresponding 'to' field`\n      );\n    }\n    if (from && to) {\n      // get values of .to and .from fields\n      fromTypeName = getNamedType(from).name.value;\n      toTypeName = getNamedType(to).name.value;\n      // assume the default relationship name\n      relationName = transformRelationName(astNode);\n      // get its relation type directive\n      typeDirectiveIndex = astNode.directives.findIndex(\n        e => e.name.value === 'relation'\n      );\n      if (typeDirectiveIndex >= 0) {\n        typeDirective = astNode.directives[typeDirectiveIndex];\n        // get the arguments of type directive\n        let args = typeDirective ? typeDirective.arguments : [];\n        if (args.length > 0) {\n          // get its name argument\n          let nameArg = args.find(e => e.name.value === 'name');\n          if (nameArg) {\n            relationName = nameArg.value.value;\n          }\n        }\n        // replace it if it exists in order to force correct configuration\n        astNode.directives[typeDirectiveIndex] = parseDirectiveSdl(`\n          @relation(\n            name: ${relationName}, \n            from: ${fromTypeName},\n            to: ${toTypeName}\n          )\n        `);\n      } else {\n        astNode.directives.push(\n          parseDirectiveSdl(`\n          @relation(\n            name: ${relationName}, \n            from: ${fromTypeName},\n            to: ${toTypeName}\n          )\n        `)\n        );\n      }\n      typeMap[typeName] = astNode;\n    }\n  });\n  return typeMap;\n};\n\nconst createOrderingFields = (astNode, typeMap, resolvers) => {\n  const fields = astNode ? astNode.fields : [];\n  let type = {};\n  let valueType = {};\n  let valueTypeName = '';\n  let fieldName = '';\n  return fields.reduce((acc, field) => {\n    type = getNamedType(field);\n    valueTypeName = type.name.value;\n    valueType = typeMap[valueTypeName];\n    if (\n      !isListType(field) &&\n      fieldIsNotIgnored(astNode, field, resolvers) &&\n      (isBasicScalar(type.name.value) ||\n        isKind(valueType, 'EnumTypeDefinition') ||\n        isTemporalType(valueTypeName))\n    ) {\n      fieldName = field.name.value;\n      acc.push({\n        kind: 'EnumValueDefinition',\n        name: {\n          kind: 'Name',\n          value: `${fieldName}_asc`\n        }\n      });\n      acc.push({\n        kind: 'EnumValueDefinition',\n        name: {\n          kind: 'Name',\n          value: `${fieldName}_desc`\n        }\n      });\n    }\n    return acc;\n  }, []);\n};\n\nconst createQueryArguments = (astNode, resolvers, typeMap) => {\n  let type = {};\n  let valueTypeName = '';\n  let valueKind = '';\n  let queryArg = {};\n  return astNode.fields.reduce((acc, t) => {\n    if (fieldIsNotIgnored(astNode, t, resolvers)) {\n      type = getNamedType(t);\n      valueTypeName = type.name.value;\n      valueKind = typeMap[valueTypeName]\n        ? typeMap[valueTypeName].kind\n        : undefined;\n      queryArg = {\n        kind: 'InputValueDefinition',\n        name: {\n          kind: 'Name',\n          value: t.name.value\n        },\n        type: type\n      };\n      if (\n        isBasicScalar(valueTypeName) ||\n        valueKind === 'EnumTypeDefinition' ||\n        valueKind === 'ScalarTypeDefinition'\n      ) {\n        acc.push(queryArg);\n      } else if (isTemporalType(valueTypeName)) {\n        queryArg.type = {\n          kind: 'NamedType',\n          name: {\n            kind: 'Name',\n            value: `${valueTypeName}Input`\n          }\n        };\n        acc.push(queryArg);\n      }\n    }\n    return acc;\n  }, []);\n};\n\nconst hasNonExcludedNodeType = (types, typeMap, rootType, config) => {\n  let type = '';\n  return types.find(e => {\n    type = typeMap[e];\n    return (\n      isNodeType(type) &&\n      type.name &&\n      shouldAugmentType(config, rootType, type.name.value)\n    );\n  });\n};\n\nconst initializeOperationTypes = (typeMap, rootTypes, config) => {\n  const queryType = rootTypes.query;\n  const mutationType = rootTypes.mutation;\n  const types = Object.keys(typeMap);\n  if (hasNonExcludedNodeType(types, typeMap, 'query', config)) {\n    typeMap = possiblyAddObjectType(typeMap, queryType);\n  }\n  if (hasNonExcludedNodeType(types, typeMap, 'mutation', config)) {\n    typeMap = possiblyAddObjectType(typeMap, mutationType);\n  }\n  return typeMap;\n};\n\nconst transformRelationName = relatedAstNode => {\n  const name = relatedAstNode.name.value;\n  let char = '';\n  let uppercased = '';\n  return Object.keys(name)\n    .reduce((acc, t) => {\n      char = name.charAt(t);\n      uppercased = char.toUpperCase();\n      if (char === uppercased && t > 0) {\n        // already uppercased\n        acc.push(`_${uppercased}`);\n      } else {\n        acc.push(uppercased);\n      }\n      return acc;\n    }, [])\n    .join('');\n};\n\nconst temporalTypes = (typeMap, types) => {\n  if (types.time === true) {\n    typeMap['_Neo4jTime'] = parse(`\n      type _Neo4jTime {\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        timezone: String\n        formatted: String\n      }\n    `).definitions[0];\n    typeMap['_Neo4jTimeInput'] = parse(`\n      input _Neo4jTimeInput {\n        hour: Int\n        minute: Int\n        second: Int\n        nanosecond: Int\n        millisecond: Int\n        microsecond: Int\n        timezone: String\n        formatted: String\n      }\n    `).definitions[0];\n  }\n  if (types.date === true) {\n    typeMap['_Neo4jDate'] = parse(`\n      type _Neo4jDate {\n        year: Int\n        month: Int\n        day: Int\n        formatted: String\n      }\n    `).definitions[0];\n    typeMap['_Neo4jDateInput'] = parse(`\n      input _Neo4jDateInput {\n        year: Int\n        month: Int\n        day: Int\n        formatted: String\n      }\n    `).definitions[0];\n  }\n  if (types.datetime === true) {\n    typeMap['_Neo4jDateTime'] = parse(`\n      type _Neo4jDateTime {\n        year: Int\n        month: Int\n        day: Int\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        timezone: String\n        formatted: String\n      }\n    `).definitions[0];\n    typeMap['_Neo4jDateTimeInput'] = parse(`\n      input _Neo4jDateTimeInput {\n        year: Int\n        month: Int\n        day: Int\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        timezone: String \n        formatted: String\n      }\n    `).definitions[0];\n  }\n  if (types.localtime === true) {\n    typeMap['_Neo4jLocalTime'] = parse(`\n      type _Neo4jLocalTime {\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        formatted: String\n      }\n    `).definitions[0];\n    typeMap['_Neo4jLocalTimeInput'] = parse(`\n      input _Neo4jLocalTimeInput {\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        formatted: String\n      }\n    `).definitions[0];\n  }\n  if (types.localdatetime === true) {\n    typeMap['_Neo4jLocalDateTime'] = parse(`\n      type _Neo4jLocalDateTime {\n        year: Int\n        month: Int\n        day: Int\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        formatted: String\n      }\n    `).definitions[0];\n    typeMap['_Neo4jLocalDateTimeInput'] = parse(`\n      input _Neo4jLocalDateTimeInput {\n        year: Int\n        month: Int\n        day: Int\n        hour: Int\n        minute: Int\n        second: Int\n        millisecond: Int\n        microsecond: Int\n        nanosecond: Int\n        formatted: String\n      }\n    `).definitions[0];\n  }\n  return typeMap;\n};\n\nconst transformTemporalFieldArgs = (field, config) => {\n  field.arguments.forEach(arg => {\n    arg.type = transformTemporalTypeName(arg.type, config, true);\n  });\n  return field;\n};\n\nconst transformTemporalFields = (typeMap, config) => {\n  Object.keys(typeMap).forEach(t => {\n    if (typeMap[t].kind === 'ObjectTypeDefinition') {\n      if (!isTemporalType(t)) {\n        typeMap[t].fields.forEach(field => {\n          // released: DateTime -> released: _Neo4jDateTime\n          field.type = transformTemporalTypeName(field.type, config);\n          field = transformTemporalFieldArgs(field, config);\n        });\n      }\n    }\n  });\n  return typeMap;\n};\n\nconst transformTemporalTypeName = (type, config, isArgument) => {\n  if (type.kind !== 'NamedType') {\n    type.type = transformTemporalTypeName(type.type, config);\n    return type;\n  }\n  if (type.kind === 'NamedType') {\n    switch (type.name.value) {\n      case 'Time': {\n        if (config.time === true) {\n          type.name.value = `_Neo4jTime${isArgument ? `Input` : ''}`;\n        }\n        break;\n      }\n      case 'Date': {\n        if (config.date === true) {\n          type.name.value = `_Neo4jDate${isArgument ? `Input` : ''}`;\n        }\n        break;\n      }\n      case 'DateTime': {\n        if (config.datetime === true) {\n          type.name.value = `_Neo4jDateTime${isArgument ? `Input` : ''}`;\n        }\n        break;\n      }\n      case 'LocalTime': {\n        if (config.localtime === true) {\n          type.name.value = `_Neo4jLocalTime${isArgument ? `Input` : ''}`;\n        }\n        break;\n      }\n      case 'LocalDateTime': {\n        if (config.localdatetime === true) {\n          type.name.value = `_Neo4jLocalDateTime${isArgument ? `Input` : ''}`;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  return type;\n};\n\nconst decideTemporalConfig = config => {\n  let defaultConfig = {\n    time: true,\n    date: true,\n    datetime: true,\n    localtime: true,\n    localdatetime: true\n  };\n  const providedConfig = config ? config.temporal : defaultConfig;\n  if (typeof providedConfig === 'boolean') {\n    if (providedConfig === false) {\n      defaultConfig.time = false;\n      defaultConfig.date = false;\n      defaultConfig.datetime = false;\n      defaultConfig.localtime = false;\n      defaultConfig.localdatetime = false;\n    }\n  } else if (typeof providedConfig === 'object') {\n    Object.keys(defaultConfig).forEach(e => {\n      if (providedConfig[e] === undefined) {\n        providedConfig[e] = defaultConfig[e];\n      }\n    });\n    defaultConfig = providedConfig;\n  }\n  return defaultConfig;\n};\n\nconst shouldAugmentType = (config, rootType, type) => {\n  return typeof config[rootType] === 'boolean'\n    ? config[rootType]\n    : // here .exclude should be an object,\n    // set at the end of excludeIgnoredTypes\n    type\n    ? !getExcludedTypes(config, rootType)[type]\n    : false;\n};\n\nconst shouldAugmentRelationField = (config, rootType, fromName, toName) =>\n  shouldAugmentType(config, rootType, fromName) &&\n  shouldAugmentType(config, rootType, toName);\n\nconst fieldIsNotIgnored = (astNode, field, resolvers) => {\n  return !getFieldDirective(field, 'neo4j_ignore');\n  // FIXME: issue related to inferences on AST field .resolve\n  // See: possiblyAddIgnoreDirective\n  // !getCustomFieldResolver(astNode, field, resolvers)\n};\n\nconst isNotSystemField = name => {\n  return name !== '_id' && name !== 'to' && name !== 'from';\n};\n\nexport const addTemporalTypes = (typeMap, config) => {\n  config = decideTemporalConfig(config);\n  typeMap = temporalTypes(typeMap, config);\n  return transformTemporalFields(typeMap, config);\n};\n\nconst getFieldArgumentsFromAst = (field, typeName, fieldIsList) => {\n  let fieldArgs = field.arguments ? field.arguments : [];\n  let paginationArgs = [];\n  if (fieldIsList) {\n    paginationArgs = possiblyAddArgument(fieldArgs, 'first', 'Int');\n    paginationArgs = possiblyAddArgument(fieldArgs, 'offset', 'Int');\n    paginationArgs = possiblyAddArgument(\n      fieldArgs,\n      'orderBy',\n      `_${typeName}Ordering`\n    );\n  }\n  const args = [paginationArgs, ...fieldArgs]\n    .reduce((acc, t) => {\n      acc.push(print(t));\n      return acc;\n    }, [])\n    .join('\\n');\n  return args.length > 0 ? `(${args})` : '';\n};\n\nconst buildMutationArguments = (mutationType, astNode, resolvers, typeMap) => {\n  const primaryKey = getPrimaryKey(astNode);\n  switch (mutationType) {\n    case 'Create': {\n      return buildCreateMutationArguments(astNode, typeMap, resolvers);\n    }\n    case 'Update': {\n      if (primaryKey) {\n        return buildUpdateMutationArguments(\n          primaryKey,\n          astNode,\n          typeMap,\n          resolvers\n        );\n      }\n    }\n    case 'Delete': {\n      if (primaryKey) {\n        return buildDeleteMutationArguments(primaryKey);\n      }\n    }\n  }\n};\n\nconst buildUpdateMutationArguments = (\n  primaryKey,\n  astNode,\n  typeMap,\n  resolvers\n) => {\n  const primaryKeyName = primaryKey.name.value;\n  const primaryKeyType = getNamedType(primaryKey);\n  // Primary key field is first arg and required for node selection\n  const parsedPrimaryKeyField = `${primaryKeyName}: ${\n    primaryKeyType.name.value\n  }!`;\n  let type = {};\n  let valueTypeName = '';\n  let valueType = {};\n  let fieldName = '';\n  let mutationArgs = [];\n  mutationArgs = astNode.fields.reduce((acc, t) => {\n    type = getNamedType(t);\n    fieldName = t.name.value;\n    valueTypeName = type.name.value;\n    valueType = typeMap[valueTypeName];\n    if (fieldIsNotIgnored(astNode, t, resolvers)) {\n      if (\n        fieldName !== primaryKeyName &&\n        isNotSystemField(fieldName) &&\n        !getFieldDirective(t, 'cypher') &&\n        (isBasicScalar(valueTypeName) ||\n          isKind(valueType, 'EnumTypeDefinition') ||\n          isKind(valueType, 'ScalarTypeDefinition') ||\n          isTemporalType(valueTypeName))\n      ) {\n        acc.push(\n          print({\n            kind: 'InputValueDefinition',\n            name: t.name,\n            // Don't require update fields, that wouldn't be very flexible\n            type: isNonNullType(t) ? t.type.type : t.type\n          })\n        );\n      }\n    }\n    return acc;\n  }, []);\n  // Add pk as first arg is other update fields exist\n  if (mutationArgs.length > 0) {\n    mutationArgs.unshift(parsedPrimaryKeyField);\n    mutationArgs = transformManagedFieldTypes(mutationArgs);\n    mutationArgs = parseInputFieldsSdl(mutationArgs);\n  }\n  return mutationArgs;\n};\n\nconst buildDeleteMutationArguments = primaryKey => {\n  let mutationArgs = [];\n  mutationArgs.push(\n    print({\n      kind: 'InputValueDefinition',\n      name: {\n        kind: 'Name',\n        value: primaryKey.name.value\n      },\n      type: {\n        kind: 'NonNullType',\n        type: {\n          kind: 'NamedType',\n          name: {\n            kind: 'Name',\n            value: getNamedType(primaryKey).name.value\n          }\n        }\n      }\n    })\n  );\n  mutationArgs = transformManagedFieldTypes(mutationArgs);\n  return parseInputFieldsSdl(mutationArgs);\n};\n\nconst buildCreateMutationArguments = (astNode, typeMap, resolvers) => {\n  let type = {};\n  let valueTypeName = '';\n  let valueType = {};\n  let fieldName = '';\n  let firstIdField = undefined;\n  let field = {};\n  let mutationArgs = astNode.fields.reduce((acc, t) => {\n    type = getNamedType(t);\n    fieldName = t.name.value;\n    valueTypeName = type.name.value;\n    valueType = typeMap[valueTypeName];\n    if (fieldIsNotIgnored(astNode, t, resolvers)) {\n      if (\n        isNotSystemField(fieldName) &&\n        !getFieldDirective(t, 'cypher') &&\n        (isBasicScalar(valueTypeName) ||\n          isKind(valueType, 'EnumTypeDefinition') ||\n          isKind(valueType, 'ScalarTypeDefinition') ||\n          isTemporalType(valueTypeName))\n      ) {\n        if (\n          isNonNullType(t) &&\n          !isListType(t) &&\n          valueTypeName === 'ID' &&\n          !firstIdField\n        ) {\n          firstIdField = t;\n          field = {\n            kind: 'InputValueDefinition',\n            name: {\n              kind: 'Name',\n              value: fieldName\n            },\n            type: {\n              kind: 'NamedType',\n              name: {\n                kind: 'Name',\n                value: valueTypeName\n              }\n            }\n          };\n        } else {\n          field = t;\n        }\n        acc.push(print(field));\n      }\n    }\n    return acc;\n  }, []);\n  // Transform managed field types: _Neo4jTime -> _Neo4jTimeInput\n  mutationArgs = transformManagedFieldTypes(mutationArgs);\n  // Use a helper to get the AST for all fields\n  mutationArgs = parseInputFieldsSdl(mutationArgs);\n  return mutationArgs;\n};\n\nconst buildRelationTypeInputFields = (astNode, fields, typeMap, resolvers) => {\n  let fieldName = '';\n  let valueTypeName = '';\n  let valueType = {};\n  let relationInputFields = fields.reduce((acc, t) => {\n    fieldName = t.name.value;\n    valueTypeName = getNamedType(t).name.value;\n    valueType = typeMap[valueTypeName];\n    if (\n      fieldIsNotIgnored(astNode, t, resolvers) &&\n      isNotSystemField(fieldName) &&\n      !getFieldDirective(t, 'cypher') &&\n      (isBasicScalar(valueTypeName) ||\n        isKind(valueType, 'EnumTypeDefinition') ||\n        isKind(valueType, 'ScalarTypeDefinition') ||\n        isTemporalType(valueTypeName))\n    ) {\n      acc.push(\n        print({\n          kind: 'InputValueDefinition',\n          name: t.name,\n          type: t.type\n        })\n      );\n    }\n    return acc;\n  }, []);\n  relationInputFields = transformManagedFieldTypes(relationInputFields);\n  return relationInputFields.join('\\n');\n};\n\nconst transformManagedFieldTypes = fields => {\n  return fields.reduce((acc, field) => {\n    if (\n      field !== '_Neo4jDateTimeInput' &&\n      field !== '_Neo4jDateInput' &&\n      field !== '_Neo4jTimeInput' &&\n      field !== '_Neo4jLocalTimeInput' &&\n      field !== '_Neo4jLocalDateTimeInput'\n    ) {\n      if (field.includes('_Neo4jDateTime')) {\n        field = field.replace('_Neo4jDateTime', '_Neo4jDateTimeInput');\n      } else if (field.includes('_Neo4jDate')) {\n        field = field.replace('_Neo4jDate', '_Neo4jDateInput');\n      } else if (field.includes('_Neo4jTime')) {\n        field = field.replace('_Neo4jTime', '_Neo4jTimeInput');\n      } else if (field.includes('_Neo4jLocalTime')) {\n        field = field.replace('_Neo4jLocalTime', '_Neo4jLocalTimeInput');\n      } else if (field.includes('_Neo4jLocalDateTime')) {\n        field = field.replace(\n          '_Neo4jLocalDateTime',\n          '_Neo4jLocalDateTimeInput'\n        );\n      }\n    }\n    acc.push(field);\n    return acc;\n  }, []);\n};\n"]}