{"version":3,"sources":["../src/utils.js"],"names":["parseArgs","extractSelections","extractQueryResult","typeIdentifiers","cypherDirectiveArgs","_isNamedMutation","isMutation","isGraphqlScalarType","isArrayType","lowFirstLetter","innerType","filtersFromSelections","getFilterParams","innerFilterParams","paramsToString","computeSkipLimit","parseArg","arg","variableValues","value","kind","name","parseInt","parseFloat","fields","_","map","values","args","length","reduce","acc","parseFieldSdl","sdl","definitions","parseInputFieldsSdl","arr","Array","isArray","join","e","type","parseDirectiveSdl","directives","printTypeMap","typeMap","extractTypeMapFromTypeDefs","astNodes","typeDefs","t","selections","fragments","cur","recursivelyExtractedSelections","selectionSet","returnType","records","variableName","result","record","get","cloneDeepWith","neo4j","isInt","field","inSafeRange","toNumber","toString","typeName","getDefaultArguments","fieldName","schemaType","_fields","defaultValue","err","variable","cypherParams","headSelection","resolveInfo","defaultArgs","queryArgs","arguments","replace","substring","split","toLowerCase","isCreateMutation","isAddMutation","isUpdateMutation","isDeleteMutation","isRemoveMutation","operation","constructor","startsWith","isRelationTypeDirectedField","isKind","isListType","isList","isNonNullType","isRequired","parent","isBasicScalar","isNodeType","astNode","getTypeDirective","undefined","find","isRelationTypePayload","directive","getRelationTypeDirectiveArgs","from","to","isRootSelection","selectionInfo","rootType","word","charAt","slice","ofType","x","argumentValue","filters","index","key","temporalArgs","paramKey","cypherDirective","temporalArgNames","push","excludedKeys","filter","includes","params","strings","param","selection","first","offset","orderByStatement","orderByVar","splitIndex","lastIndexOf","order","orderBy","computeOrderBy","orderByArgs","orderByArray","orderByStatments","possiblySetFirstId","statements","getNamedType","getQueryArguments","schema","getQueryType","getFields","getMutationArguments","getMutationType","buildCypherParameters","dataParams","paramKeys","paramName","fieldAst","fieldType","isTemporalInputType","formatted","temporalFunction","getTemporalCypherConstructor","temporalParam","count","i","forEach","int","directiveWithArgs","directiveName","fieldDirective","directiveArgument","ret","relationDirective","relatedAstNode","getFieldDirective","getRelationDirection","direction","a","Error","getRelationName","addDirectiveDeclarations","getQueryCypherDirective","getMutationCypherDirective","relationshipType","getRelationMutationPayloadFieldsFromAst","firstNonNullAndIdField","valueTypeName","firstIdField","firstNonNullField","firstField","getPrimaryKey","pk","createOperationMap","safeVar","asStr","safeLabel","l","escapeInner","decideNestedVariableName","schemaTypeRelation","innerSchemaTypeRelation","parentSelectionInfo","fromTypeName","toTypeName","initializeMutationParams","mutationTypeCypherDirective","otherParams","getOuterSkipLimit","getPayloadSelections","filteredFieldNodes","fieldNodes","n","filterNullParams","nulls","nonNulls","splitSelectionParameters","primaryKeyArgName","primaryKeyParam","updateParams","isTemporalField","isTemporalType","cypherFunction","getTemporalArguments","temporalPredicateClauses","parentParam","argName","paramIndex","paramValue","excludeIgnoredTypes","config","queryExclusionMap","mutationExclusionMap","excludedQueries","getExcludedTypes","excludedMutations","query","exclude","mutation","possiblyAddIgnoreDirective","resolvers","getCustomFieldResolver","typeResolver","removeIgnoredFields","schemaTypeField"],"mappings":"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","file":"utils.js","sourcesContent":["import { print, parse } from 'graphql';\nimport { possiblyAddArgument } from './augment';\nimport { v1 as neo4j } from 'neo4j-driver';\nimport _ from 'lodash';\nimport filter from 'lodash/filter';\n\nfunction parseArg(arg, variableValues) {\n  switch (arg.value.kind) {\n    case 'Variable': {\n      return variableValues[arg.value.name.value];\n    }\n    case 'IntValue': {\n      return parseInt(arg.value.value);\n    }\n    case 'FloatValue': {\n      return parseFloat(arg.value.value);\n    }\n    case 'Variable': {\n      return variableValues[arg.name.value];\n    }\n    case 'ObjectValue': {\n      return parseArgs(arg.value.fields, {});\n    }\n    case 'ListValue': {\n      return _.map(arg.value.values, value =>\n        parseArg({ value }, variableValues)\n      );\n    }\n    default: {\n      return arg.value.value;\n    }\n  }\n}\n\nexport function parseArgs(args, variableValues) {\n  if (!args || args.length === 0) {\n    return {};\n  }\n  return args.reduce((acc, arg) => {\n    acc[arg.name.value] = parseArg(arg, variableValues);\n    return acc;\n  }, {});\n}\n\nexport const parseFieldSdl = sdl => {\n  return sdl ? parse(`type Type { ${sdl} }`).definitions[0].fields[0] : {};\n};\n\nexport const parseInputFieldsSdl = fields => {\n  let arr = [];\n  if (Array.isArray(fields)) {\n    fields = fields.join('\\n');\n    arr = fields ? parse(`type Type { ${fields} }`).definitions[0].fields : [];\n    arr = arr.map(e => ({\n      kind: 'InputValueDefinition',\n      name: e.name,\n      type: e.type\n    }));\n  }\n  return arr;\n};\n\nexport const parseDirectiveSdl = sdl => {\n  return sdl\n    ? parse(`type Type { field: String ${sdl} }`).definitions[0].fields[0]\n        .directives[0]\n    : {};\n};\n\nexport const printTypeMap = typeMap => {\n  return print({\n    kind: 'Document',\n    definitions: Object.values(typeMap)\n  });\n};\n\nexport const extractTypeMapFromTypeDefs = typeDefs => {\n  // TODO accept alternative typeDefs formats (arr of strings, ast, etc.)\n  // into a single string for parse, add validatation\n  const astNodes = parse(typeDefs).definitions;\n  return astNodes.reduce((acc, t) => {\n    if (t.name) acc[t.name.value] = t;\n    return acc;\n  }, {});\n};\n\nexport function extractSelections(selections, fragments) {\n  // extract any fragment selection sets into a single array of selections\n  return selections.reduce((acc, cur) => {\n    if (cur.kind === 'FragmentSpread') {\n      const recursivelyExtractedSelections = extractSelections(\n        fragments[cur.name.value].selectionSet.selections,\n        fragments\n      );\n      return [...acc, ...recursivelyExtractedSelections];\n    } else {\n      return [...acc, cur];\n    }\n  }, []);\n}\n\nexport function extractQueryResult({ records }, returnType) {\n  const { variableName } = typeIdentifiers(returnType);\n  let result = null;\n  if (isArrayType(returnType)) {\n    result = records.map(record => record.get(variableName));\n  } else if (records.length) {\n    // could be object or scalar\n    result = records[0].get(variableName);\n    result = Array.isArray(result) ? result[0] : result;\n  }\n  // handle Integer fields\n  result = _.cloneDeepWith(result, field => {\n    if (neo4j.isInt(field)) {\n      // See: https://neo4j.com/docs/api/javascript-driver/current/class/src/v1/integer.js~Integer.html\n      return field.inSafeRange() ? field.toNumber() : field.toString();\n    }\n  });\n  return result;\n}\n\nexport function typeIdentifiers(returnType) {\n  const typeName = innerType(returnType).toString();\n  return {\n    variableName: lowFirstLetter(typeName),\n    typeName\n  };\n}\n\nfunction getDefaultArguments(fieldName, schemaType) {\n  // get default arguments for this field from schema\n  try {\n    return schemaType._fields[fieldName].args.reduce((acc, arg) => {\n      acc[arg.name] = arg.defaultValue;\n      return acc;\n    }, {});\n  } catch (err) {\n    return {};\n  }\n}\n\nexport function cypherDirectiveArgs(\n  variable,\n  cypherParams,\n  headSelection,\n  schemaType,\n  resolveInfo\n) {\n  const defaultArgs = getDefaultArguments(headSelection.name.value, schemaType);\n  const queryArgs = parseArgs(\n    headSelection.arguments,\n    resolveInfo.variableValues\n  );\n\n  const args = JSON.stringify(Object.assign(defaultArgs, queryArgs)).replace(\n    /\\\"([^(\\\")\"]+)\\\":/g,\n    ' $1: '\n  );\n\n  return args === '{}'\n    ? `{this: ${variable}, ${\n        cypherParams ? `cypherParams: $cypherParams` : ''\n      }${args.substring(1)}`\n    : `{this: ${variable},${\n        cypherParams ? ` cypherParams: $cypherParams,` : ''\n      }${args.substring(1)}`;\n}\n\nexport function _isNamedMutation(name) {\n  return function(resolveInfo) {\n    return (\n      isMutation(resolveInfo) &&\n      resolveInfo.fieldName.split(/(?=[A-Z])/)[0].toLowerCase() ===\n        name.toLowerCase()\n    );\n  };\n}\n\nexport const isCreateMutation = _isNamedMutation('create');\n\nexport const isAddMutation = _isNamedMutation('add');\n\nexport const isUpdateMutation = _isNamedMutation('update');\n\nexport const isDeleteMutation = _isNamedMutation('delete');\n\nexport const isRemoveMutation = _isNamedMutation('remove');\n\nexport function isMutation(resolveInfo) {\n  return resolveInfo.operation.operation === 'mutation';\n}\n\nexport function isGraphqlScalarType(type) {\n  return (\n    type.constructor.name === 'GraphQLScalarType' ||\n    type.constructor.name === 'GraphQLEnumType'\n  );\n}\n\nexport function isArrayType(type) {\n  return type ? type.toString().startsWith('[') : false;\n}\n\nexport const isRelationTypeDirectedField = fieldName => {\n  return fieldName === 'from' || fieldName === 'to';\n};\n\nexport const isKind = (type, kind) => type && type.kind && type.kind === kind;\n\nexport const isListType = (type, isList = false) => {\n  if (!isKind(type, 'NamedType')) {\n    if (isKind(type, 'ListType')) isList = true;\n    return isListType(type.type, isList);\n  }\n  return isList;\n};\n\nexport const isNonNullType = (type, isRequired = false, parent = {}) => {\n  if (!isKind(type, 'NamedType')) {\n    return isNonNullType(type.type, isRequired, type);\n  }\n  if (isKind(parent, 'NonNullType')) {\n    isRequired = true;\n  }\n  return isRequired;\n};\n\nexport const isBasicScalar = name => {\n  return (\n    name === 'ID' ||\n    name === 'String' ||\n    name === 'Float' ||\n    name === 'Int' ||\n    name === 'Boolean'\n  );\n};\n\nexport const isNodeType = astNode => {\n  return (\n    astNode &&\n    // must be graphql object type\n    astNode.kind === 'ObjectTypeDefinition' &&\n    // is not Query or Mutation type\n    astNode.name.value !== 'Query' &&\n    astNode.name.value !== 'Mutation' &&\n    // does not have relation type directive\n    getTypeDirective(astNode, 'relation') === undefined &&\n    // does not have from and to fields; not relation type\n    astNode.fields &&\n    astNode.fields.find(e => e.name.value === 'from') === undefined &&\n    astNode.fields.find(e => e.name.value === 'to') === undefined\n  );\n};\n\nexport const isRelationTypePayload = schemaType => {\n  const astNode = schemaType ? schemaType.astNode : undefined;\n  const directive = astNode ? getRelationTypeDirectiveArgs(astNode) : undefined;\n  return astNode && astNode.fields && directive\n    ? astNode.fields.find(e => {\n        return e.name.value === directive.from || e.name.value === directive.to;\n      })\n    : undefined;\n};\n\nexport const isRootSelection = ({ selectionInfo, rootType }) =>\n  selectionInfo && selectionInfo.rootType === rootType;\n\nexport function lowFirstLetter(word) {\n  return word.charAt(0).toLowerCase() + word.slice(1);\n}\n\nexport function innerType(type) {\n  return type.ofType ? innerType(type.ofType) : type;\n}\n\nexport function filtersFromSelections(selections, variableValues) {\n  if (\n    selections &&\n    selections.length &&\n    selections[0].arguments &&\n    selections[0].arguments.length\n  ) {\n    return selections[0].arguments.reduce((result, x) => {\n      (result[x.name.value] = argumentValue(\n        selections[0],\n        x.name.value,\n        variableValues\n      )) || x.value.value;\n      return result;\n    }, {});\n  }\n  return {};\n}\n\nexport function getFilterParams(filters, index) {\n  return Object.entries(filters).reduce((result, [key, value]) => {\n    result[key] = index\n      ? {\n          value,\n          index\n        }\n      : value;\n    return result;\n  }, {});\n}\n\nexport function innerFilterParams(\n  filters,\n  temporalArgs,\n  paramKey,\n  cypherDirective\n) {\n  const temporalArgNames = temporalArgs\n    ? temporalArgs.reduce((acc, t) => {\n        acc.push(t.name.value);\n        return acc;\n      }, [])\n    : [];\n  // don't exclude first, offset, orderBy args for cypher directives\n  const excludedKeys = cypherDirective ? [] : ['first', 'offset', 'orderBy'];\n\n  return Object.keys(filters).length > 0\n    ? Object.entries(filters)\n        // exclude temporal arguments\n        .filter(\n          ([key]) => ![...excludedKeys, ...temporalArgNames].includes(key)\n        )\n        .map(([key, value]) => {\n          return { key, paramKey, value };\n        })\n    : [];\n}\n\nexport function paramsToString(params, cypherParams) {\n  if (params.length > 0) {\n    const strings = _.map(params, param => {\n      return `${param.key}:${param.paramKey ? `$${param.paramKey}.` : '$'}${\n        typeof param.value.index === 'undefined'\n          ? param.key\n          : `${param.value.index}_${param.key}`\n      }`;\n    });\n    return `{${strings.join(', ')}${\n      cypherParams ? `, cypherParams: $cypherParams}` : '}'\n    }`;\n  }\n  return '';\n}\n\nexport function computeSkipLimit(selection, variableValues) {\n  let first = argumentValue(selection, 'first', variableValues);\n  let offset = argumentValue(selection, 'offset', variableValues);\n\n  if (first === null && offset === null) return '';\n  if (offset === null) return `[..${first}]`;\n  if (first === null) return `[${offset}..]`;\n  return `[${offset}..${parseInt(offset) + parseInt(first)}]`;\n}\n\nfunction orderByStatement(resolveInfo, orderByVar) {\n  const splitIndex = orderByVar.lastIndexOf('_');\n  const order = orderByVar.substring(splitIndex + 1);\n  const orderBy = orderByVar.substring(0, splitIndex);\n  const { variableName } = typeIdentifiers(resolveInfo.returnType);\n  return ` ${variableName}.${orderBy} ${order === 'asc' ? 'ASC' : 'DESC'} `;\n}\n\nexport const computeOrderBy = (resolveInfo, selection) => {\n  const orderByArgs = argumentValue(\n    resolveInfo.operation.selectionSet.selections[0],\n    'orderBy',\n    resolveInfo.variableValues\n  );\n\n  if (orderByArgs == undefined) {\n    return '';\n  }\n\n  const orderByArray = Array.isArray(orderByArgs) ? orderByArgs : [orderByArgs];\n  const orderByStatments = orderByArray.map(orderByVar =>\n    orderByStatement(resolveInfo, orderByVar)\n  );\n\n  return ' ORDER BY' + orderByStatments.join(',');\n};\n\nexport const possiblySetFirstId = ({ args, statements, params }) => {\n  const arg = args.find(e => getNamedType(e).name.value === 'ID');\n  // arg is the first ID field if it exists, and we set the value\n  // if no value is provided for the field name (arg.name.value) in params\n  if (arg && arg.name.value && params[arg.name.value] === undefined) {\n    statements.push(`${arg.name.value}: apoc.create.uuid()`);\n  }\n  return statements;\n};\n\nexport const getQueryArguments = resolveInfo => {\n  return resolveInfo.schema.getQueryType().getFields()[resolveInfo.fieldName]\n    .astNode.arguments;\n};\n\nexport const getMutationArguments = resolveInfo => {\n  return resolveInfo.schema.getMutationType().getFields()[resolveInfo.fieldName]\n    .astNode.arguments;\n};\n\n// TODO refactor\nexport const buildCypherParameters = ({\n  args,\n  statements = [],\n  params,\n  paramKey\n}) => {\n  const dataParams = paramKey ? params[paramKey] : params;\n  const paramKeys = dataParams ? Object.keys(dataParams) : [];\n  if (args) {\n    statements = paramKeys.reduce((acc, paramName) => {\n      const param = paramKey ? params[paramKey][paramName] : params[paramName];\n      // Get the AST definition for the argument matching this param name\n      const fieldAst = args.find(arg => arg.name.value === paramName);\n      if (fieldAst) {\n        const fieldType = getNamedType(fieldAst.type);\n        if (isTemporalInputType(fieldType.name.value)) {\n          const formatted = param.formatted;\n          const temporalFunction = getTemporalCypherConstructor(fieldAst);\n          if (temporalFunction) {\n            // Prefer only using formatted, if provided\n            if (formatted) {\n              if (paramKey) params[paramKey][paramName] = formatted;\n              else params[paramName] = formatted;\n              acc.push(\n                `${paramName}: ${temporalFunction}($${\n                  paramKey ? `${paramKey}.` : ''\n                }${paramName})`\n              );\n            } else {\n              let temporalParam = {};\n              if (Array.isArray(param)) {\n                const count = param.length;\n                let i = 0;\n                for (; i < count; ++i) {\n                  temporalParam = param[i];\n                  const formatted = temporalParam.formatted;\n                  if (temporalParam.formatted) {\n                    paramKey\n                      ? (params[paramKey][paramName] = formatted)\n                      : (params[paramName] = formatted);\n                  } else {\n                    Object.keys(temporalParam).forEach(e => {\n                      if (Number.isInteger(temporalParam[e])) {\n                        paramKey\n                          ? (params[paramKey][paramName][i][e] = neo4j.int(\n                              temporalParam[e]\n                            ))\n                          : (params[paramName][i][e] = neo4j.int(\n                              temporalParam[e]\n                            ));\n                      }\n                    });\n                  }\n                }\n                acc.push(\n                  `${paramName}: [value IN $${\n                    paramKey ? `${paramKey}.` : ''\n                  }${paramName} | ${temporalFunction}(value)]`\n                );\n              } else {\n                temporalParam = paramKey\n                  ? params[paramKey][paramName]\n                  : params[paramName];\n                const formatted = temporalParam.formatted;\n                if (temporalParam.formatted) {\n                  paramKey\n                    ? (params[paramKey][paramName] = formatted)\n                    : (params[paramName] = formatted);\n                } else {\n                  Object.keys(temporalParam).forEach(e => {\n                    if (Number.isInteger(temporalParam[e])) {\n                      paramKey\n                        ? (params[paramKey][paramName][e] = neo4j.int(\n                            temporalParam[e]\n                          ))\n                        : (params[paramName][e] = neo4j.int(temporalParam[e]));\n                    }\n                  });\n                }\n                acc.push(\n                  `${paramName}: ${temporalFunction}($${\n                    paramKey ? `${paramKey}.` : ''\n                  }${paramName})`\n                );\n              }\n            }\n          }\n        } else {\n          // normal case\n          acc.push(\n            `${paramName}:$${paramKey ? `${paramKey}.` : ''}${paramName}`\n          );\n        }\n      }\n      return acc;\n    }, statements);\n  }\n  if (paramKey) {\n    params[paramKey] = dataParams;\n  }\n  return [params, statements];\n};\n\n// TODO refactor to handle Query/Mutation type schema directives\nconst directiveWithArgs = (directiveName, args) => (schemaType, fieldName) => {\n  function fieldDirective(schemaType, fieldName, directiveName) {\n    return !isGraphqlScalarType(schemaType)\n      ? schemaType\n          .getFields()\n          [fieldName].astNode.directives.find(\n            e => e.name.value === directiveName\n          )\n      : {};\n  }\n\n  function directiveArgument(directive, name) {\n    return directive && directive.arguments\n      ? directive.arguments.find(e => e.name.value === name).value.value\n      : [];\n  }\n\n  const directive = fieldDirective(schemaType, fieldName, directiveName);\n  const ret = {};\n  if (directive) {\n    Object.assign(\n      ret,\n      ...args.map(key => ({\n        [key]: directiveArgument(directive, key)\n      }))\n    );\n  }\n  return ret;\n};\n\nexport const cypherDirective = directiveWithArgs('cypher', ['statement']);\n\nexport const relationDirective = directiveWithArgs('relation', [\n  'name',\n  'direction'\n]);\n\nexport const getTypeDirective = (relatedAstNode, name) => {\n  return relatedAstNode && relatedAstNode.directives\n    ? relatedAstNode.directives.find(e => e.name.value === name)\n    : undefined;\n};\n\nexport const getFieldDirective = (field, directive) => {\n  return (\n    field &&\n    field.directives &&\n    field.directives.find(e => e.name.value === directive)\n  );\n};\n\nexport const getRelationDirection = relationDirective => {\n  let direction = {};\n  try {\n    direction = relationDirective.arguments.filter(\n      a => a.name.value === 'direction'\n    )[0];\n    return direction.value.value;\n  } catch (e) {\n    // FIXME: should we ignore this error to define default behavior?\n    throw new Error('No direction argument specified on @relation directive');\n  }\n};\n\nexport const getRelationName = relationDirective => {\n  let name = {};\n  try {\n    name = relationDirective.arguments.filter(a => a.name.value === 'name')[0];\n    return name.value.value;\n  } catch (e) {\n    // FIXME: should we ignore this error to define default behavior?\n    throw new Error('No name argument specified on @relation directive');\n  }\n};\n\nexport const addDirectiveDeclarations = typeMap => {\n  // overwrites any provided directive declarations for system directive names\n  typeMap['cypher'] = parse(\n    `directive @cypher(statement: String) on FIELD_DEFINITION`\n  ).definitions[0];\n  typeMap['relation'] = parse(\n    `directive @relation(name: String, direction: _RelationDirections, from: String, to: String) on FIELD_DEFINITION | OBJECT`\n  ).definitions[0];\n  typeMap['MutationMeta'] = parse(\n    `directive @MutationMeta(relationship: String, from: String, to: String) on FIELD_DEFINITION`\n  ).definitions[0];\n  typeMap['_RelationDirections'] = parse(\n    `enum _RelationDirections { IN OUT }`\n  ).definitions[0];\n  typeMap['neo4j_ignore'] = parse(\n    `directive @neo4j_ignore on FIELD_DEFINITION`\n  ).definitions[0];\n  return typeMap;\n};\n\nexport const getQueryCypherDirective = resolveInfo => {\n  return resolveInfo.schema\n    .getQueryType()\n    .getFields()\n    [resolveInfo.fieldName].astNode.directives.find(x => {\n      return x.name.value === 'cypher';\n    });\n};\n\nexport const getMutationCypherDirective = resolveInfo => {\n  return resolveInfo.schema\n    .getMutationType()\n    .getFields()\n    [resolveInfo.fieldName].astNode.directives.find(x => {\n      return x.name.value === 'cypher';\n    });\n};\n\nfunction argumentValue(selection, name, variableValues) {\n  let arg = selection.arguments.find(a => a.name.value === name);\n  if (!arg) {\n    return null;\n  } else {\n    return parseArg(arg, variableValues);\n  }\n}\n\nexport const getRelationTypeDirectiveArgs = relationshipType => {\n  const directive =\n    relationshipType && relationshipType.directives\n      ? relationshipType.directives.find(e => e.name.value === 'relation')\n      : undefined;\n  return directive\n    ? {\n        name: directive.arguments.find(e => e.name.value === 'name').value\n          .value,\n        from: directive.arguments.find(e => e.name.value === 'from').value\n          .value,\n        to: directive.arguments.find(e => e.name.value === 'to').value.value\n      }\n    : undefined;\n};\n\nexport const getRelationMutationPayloadFieldsFromAst = relatedAstNode => {\n  let isList = false;\n  let fieldName = '';\n  return relatedAstNode.fields\n    .reduce((acc, t) => {\n      fieldName = t.name.value;\n      if (fieldName !== 'to' && fieldName !== 'from') {\n        isList = isListType(t);\n        // Use name directly in order to prevent requiring required fields on the payload type\n        acc.push(\n          `${fieldName}: ${isList ? '[' : ''}${getNamedType(t).name.value}${\n            isList ? `]` : ''\n          }${print(t.directives)}`\n        );\n      }\n      return acc;\n    }, [])\n    .join('\\n');\n};\n\nexport const getNamedType = type => {\n  if (type.kind !== 'NamedType') {\n    return getNamedType(type.type);\n  }\n  return type;\n};\n\nconst firstNonNullAndIdField = fields => {\n  let valueTypeName = '';\n  return fields.find(e => {\n    valueTypeName = getNamedType(e).name.value;\n    return (\n      e.name.value !== '_id' &&\n      e.type.kind === 'NonNullType' &&\n      valueTypeName === 'ID'\n    );\n  });\n};\n\nconst firstIdField = fields => {\n  let valueTypeName = '';\n  return fields.find(e => {\n    valueTypeName = getNamedType(e).name.value;\n    return e.name.value !== '_id' && valueTypeName === 'ID';\n  });\n};\n\nconst firstNonNullField = fields => {\n  let valueTypeName = '';\n  return fields.find(e => {\n    valueTypeName = getNamedType(e).name.value;\n    return valueTypeName === 'NonNullType';\n  });\n};\n\nconst firstField = fields => {\n  return fields.find(e => {\n    return e.name.value !== '_id';\n  });\n};\n\nexport const getPrimaryKey = astNode => {\n  let fields = astNode.fields;\n  let pk = undefined;\n  // remove all ignored fields\n  fields = fields.filter(field => !getFieldDirective(field, 'neo4j_ignore'));\n  if (!fields.length) return pk;\n  pk = firstNonNullAndIdField(fields);\n  if (!pk) {\n    pk = firstIdField(fields);\n  }\n  if (!pk) {\n    pk = firstNonNullField(fields);\n  }\n  if (!pk) {\n    pk = firstField(fields);\n  }\n  return pk;\n};\n\nexport const createOperationMap = type => {\n  const fields = type ? type.fields : [];\n  return fields.reduce((acc, t) => {\n    acc[t.name.value] = t;\n    return acc;\n  }, {});\n};\n\n/**\n * Render safe a variable name according to cypher rules\n * @param {String} i input variable name\n * @returns {String} escaped text suitable for interpolation in cypher\n */\nexport const safeVar = i => {\n  // There are rare cases where the var input is an object and has to be stringified\n  // to produce the right output.\n  const asStr = `${i}`;\n\n  // Rules: https://neo4j.com/docs/developer-manual/current/cypher/syntax/naming/\n  return '`' + asStr.replace(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,.\\/]/g, '_') + '`';\n};\n\n/**\n * Render safe a label name by enclosing it in backticks and escaping any\n * existing backtick if present.\n * @param {String} l a label name\n * @returns {String} an escaped label name suitable for cypher concat\n */\nexport const safeLabel = l => {\n  const asStr = `${l}`;\n  const escapeInner = asStr.replace(/\\`/g, '\\\\`');\n  return '`' + escapeInner + '`';\n};\n\nexport const decideNestedVariableName = ({\n  schemaTypeRelation,\n  innerSchemaTypeRelation,\n  variableName,\n  fieldName,\n  parentSelectionInfo\n}) => {\n  if (\n    isRootSelection({\n      selectionInfo: parentSelectionInfo,\n      rootType: 'relationship'\n    }) &&\n    isRelationTypeDirectedField(fieldName)\n  ) {\n    return parentSelectionInfo[fieldName];\n  } else if (schemaTypeRelation) {\n    const fromTypeName = schemaTypeRelation.from;\n    const toTypeName = schemaTypeRelation.to;\n    if (fromTypeName === toTypeName) {\n      if (fieldName === 'from' || fieldName === 'to') {\n        return variableName + '_' + fieldName;\n      } else {\n        // Case of a reflexive relationship type's directed field\n        // being renamed to its node type value\n        // ex: from: User -> User: User\n        return variableName;\n      }\n    }\n  } else {\n    // Types without @relation directives are assumed to be node types\n    // and only node types can have fields whose values are relation types\n    if (innerSchemaTypeRelation) {\n      // innerSchemaType is a field payload type using a @relation directive\n      if (innerSchemaTypeRelation.from === innerSchemaTypeRelation.to) {\n        return variableName;\n      }\n    } else {\n      // related types are different\n      return variableName + '_' + fieldName;\n    }\n  }\n  return variableName + '_' + fieldName;\n};\n\nexport const initializeMutationParams = ({\n  resolveInfo,\n  mutationTypeCypherDirective,\n  otherParams,\n  first,\n  offset\n}) => {\n  return (isCreateMutation(resolveInfo) || isUpdateMutation(resolveInfo)) &&\n    !mutationTypeCypherDirective\n    ? { params: otherParams, ...{ first, offset } }\n    : { ...otherParams, ...{ first, offset } };\n};\n\nexport const getOuterSkipLimit = first =>\n  `SKIP $offset${first > -1 ? ' LIMIT $first' : ''}`;\n\nexport const getPayloadSelections = resolveInfo => {\n  const filteredFieldNodes = filter(\n    resolveInfo.fieldNodes,\n    n => n.name.value === resolveInfo.fieldName\n  );\n  if (filteredFieldNodes[0] && filteredFieldNodes[0].selectionSet) {\n    // FIXME: how to handle multiple fieldNode matches\n    const x = extractSelections(\n      filteredFieldNodes[0].selectionSet.selections,\n      resolveInfo.fragments\n    );\n    return x;\n  }\n  return [];\n};\n\nexport const filterNullParams = ({ offset, first, otherParams }) => {\n  return Object.entries({\n    ...{ offset, first },\n    ...otherParams\n  }).reduce(\n    ([nulls, nonNulls], [key, value]) => {\n      if (value === null) {\n        nulls[key] = value;\n      } else {\n        nonNulls[key] = value;\n      }\n      return [nulls, nonNulls];\n    },\n    [{}, {}]\n  );\n};\n\nexport const splitSelectionParameters = (\n  params,\n  primaryKeyArgName,\n  paramKey\n) => {\n  const paramKeys = paramKey\n    ? Object.keys(params[paramKey])\n    : Object.keys(params);\n  const [primaryKeyParam, updateParams] = paramKeys.reduce(\n    (acc, t) => {\n      if (t === primaryKeyArgName) {\n        if (paramKey) {\n          acc[0][t] = params[paramKey][t];\n        } else {\n          acc[0][t] = params[t];\n        }\n      } else {\n        if (paramKey) {\n          if (acc[1][paramKey] === undefined) acc[1][paramKey] = {};\n          acc[1][paramKey][t] = params[paramKey][t];\n        } else {\n          acc[1][t] = params[t];\n        }\n      }\n      return acc;\n    },\n    [{}, {}]\n  );\n  const first = params.first;\n  const offset = params.offset;\n  if (first !== undefined) updateParams['first'] = first;\n  if (offset !== undefined) updateParams['offset'] = offset;\n  return [primaryKeyParam, updateParams];\n};\n\nexport const isTemporalField = (schemaType, name) => {\n  const type = schemaType ? schemaType.name : '';\n  return (\n    (isTemporalType(type) && name === 'year') ||\n    name === 'month' ||\n    name === 'day' ||\n    name === 'hour' ||\n    name === 'minute' ||\n    name === 'second' ||\n    name === 'microsecond' ||\n    name === 'millisecond' ||\n    name === 'nanosecond' ||\n    name === 'timezone' ||\n    name === 'formatted'\n  );\n};\n\nexport const isTemporalType = name => {\n  return (\n    name === '_Neo4jTime' ||\n    name === '_Neo4jDate' ||\n    name === '_Neo4jDateTime' ||\n    name === '_Neo4jLocalTime' ||\n    name === '_Neo4jLocalDateTime'\n  );\n};\n\nexport const getTemporalCypherConstructor = fieldAst => {\n  let cypherFunction = undefined;\n  const type = fieldAst ? getNamedType(fieldAst.type).name.value : '';\n  switch (type) {\n    case '_Neo4jTimeInput':\n      cypherFunction = 'time';\n      break;\n    case '_Neo4jDateInput':\n      cypherFunction = 'date';\n      break;\n    case '_Neo4jDateTimeInput':\n      cypherFunction = 'datetime';\n      break;\n    case '_Neo4jLocalTimeInput':\n      cypherFunction = 'localtime';\n      break;\n    case '_Neo4jLocalDateTimeInput':\n      cypherFunction = 'localdatetime';\n      break;\n    default:\n      break;\n  }\n  return cypherFunction;\n};\n\nexport const getTemporalArguments = args => {\n  return args\n    ? args.reduce((acc, t) => {\n        if (!t) {\n          return acc;\n        }\n        const fieldType = getNamedType(t.type).name.value;\n        if (isTemporalInputType(fieldType)) acc.push(t);\n        return acc;\n      }, [])\n    : [];\n};\n\nexport const isTemporalInputType = name => {\n  return (\n    name === '_Neo4jTimeInput' ||\n    name === '_Neo4jDateInput' ||\n    name === '_Neo4jDateTimeInput' ||\n    name === '_Neo4jLocalTimeInput' ||\n    name === '_Neo4jLocalDateTimeInput'\n  );\n};\n\nexport const temporalPredicateClauses = (\n  filters,\n  variableName,\n  temporalArgs,\n  parentParam\n) => {\n  return temporalArgs.reduce((acc, t) => {\n    // For every temporal argument\n    const argName = t.name.value;\n    let temporalParam = filters[argName];\n    if (temporalParam) {\n      // If a parameter value has been provided for it check whether\n      // the provided param value is in an indexed object for a nested argument\n      const paramIndex = temporalParam.index;\n      const paramValue = temporalParam.value;\n      // If it is, set and use its .value\n      if (paramValue) temporalParam = paramValue;\n      if (temporalParam['formatted']) {\n        // Only the dedicated 'formatted' arg is used if it is provided\n        acc.push(\n          `${variableName}.${argName} = ${getTemporalCypherConstructor(t)}($${\n            // use index if provided, for nested arguments\n            typeof paramIndex === 'undefined'\n              ? `${parentParam ? `${parentParam}.` : ''}${argName}.formatted`\n              : `${\n                  parentParam ? `${parentParam}.` : ''\n                }${paramIndex}_${argName}.formatted`\n          })`\n        );\n      } else {\n        Object.keys(temporalParam).forEach(e => {\n          acc.push(\n            `${variableName}.${argName}.${e} = $${\n              typeof paramIndex === 'undefined'\n                ? `${parentParam ? `${parentParam}.` : ''}${argName}`\n                : `${\n                    parentParam ? `${parentParam}.` : ''\n                  }${paramIndex}_${argName}`\n            }.${e}`\n          );\n        });\n      }\n    }\n    return acc;\n  }, []);\n};\n\n// An ignored type is a type without at least 1 non-ignored field\nexport const excludeIgnoredTypes = (typeMap, config = {}) => {\n  const queryExclusionMap = {};\n  const mutationExclusionMap = {};\n  // If .query is an object and .exclude is provided, use it, else use new arr\n  let excludedQueries = getExcludedTypes(config, 'query');\n  let excludedMutations = getExcludedTypes(config, 'mutation');\n  // Add any ignored types to exclusion arrays\n  Object.keys(typeMap).forEach(name => {\n    if (\n      typeMap[name].fields &&\n      !typeMap[name].fields.find(\n        field => !getFieldDirective(field, 'neo4j_ignore')\n      )\n    ) {\n      // All fields are ignored, so exclude the type\n      excludedQueries.push(name);\n      excludedMutations.push(name);\n    }\n  });\n  // As long as the API is still allowed, convert the exclusion arrays\n  // to a boolean map for quicker reference later\n  if (config.query !== false) {\n    excludedQueries.forEach(e => {\n      queryExclusionMap[e] = true;\n    });\n    config.query = { exclude: queryExclusionMap };\n  }\n  if (config.mutation !== false) {\n    excludedMutations.forEach(e => {\n      mutationExclusionMap[e] = true;\n    });\n    config.mutation = { exclude: mutationExclusionMap };\n  }\n  return config;\n};\n\nexport const getExcludedTypes = (config, rootType) => {\n  return config &&\n    rootType &&\n    config[rootType] &&\n    typeof config[rootType] === 'object' &&\n    config[rootType].exclude\n    ? config[rootType].exclude\n    : [];\n};\n\nexport const possiblyAddIgnoreDirective = (\n  astNode,\n  typeMap,\n  resolvers,\n  config\n) => {\n  const fields = astNode && astNode.fields ? astNode.fields : [];\n  let valueTypeName = '';\n  return fields.map(field => {\n    // for any field of any type, if a custom resolver is provided\n    // but there is no @ignore directive\n    valueTypeName = getNamedType(field).name.value;\n    if (\n      // has a custom resolver but not a directive\n      getCustomFieldResolver(astNode, field, resolvers) &&\n      !getFieldDirective(field, 'neo4j_ignore') &&\n      // fields that behave in ways specific to the neo4j mapping do not recieve ignore\n      // directives and can instead have their data post-processed by a custom field resolver\n      !getFieldDirective(field, 'relation') &&\n      !getFieldDirective(field, 'cypher') &&\n      !getTypeDirective(typeMap[valueTypeName], 'relation') &&\n      !isTemporalType(valueTypeName)\n    ) {\n      // possibly initialize directives\n      if (!field.directives) field.directives = [];\n      // add the ignore directive for use in runtime translation\n      field.directives.push(parseDirectiveSdl(`@neo4j_ignore`));\n    }\n    return field;\n  });\n};\n\nexport const getCustomFieldResolver = (astNode, field, resolvers) => {\n  const typeResolver =\n    astNode && astNode.name && astNode.name.value\n      ? resolvers[astNode.name.value]\n      : undefined;\n  return typeResolver ? typeResolver[field.name.value] : undefined;\n};\n\nexport const removeIgnoredFields = (schemaType, selections) => {\n  if (!isGraphqlScalarType(schemaType) && selections && selections.length) {\n    let schemaTypeField = '';\n    selections = selections.filter(e => {\n      if (e.kind === 'Field') {\n        // so check if this field is ignored\n        schemaTypeField = schemaType.getFields()[e.name.value];\n        return (\n          schemaTypeField &&\n          schemaTypeField.astNode &&\n          !getFieldDirective(schemaTypeField.astNode, 'neo4j_ignore')\n        );\n      }\n      // keep element by default\n      return true;\n    });\n  }\n  return selections;\n};\n"]}