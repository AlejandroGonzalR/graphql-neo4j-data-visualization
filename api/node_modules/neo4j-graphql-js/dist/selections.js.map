{"version":3,"sources":["../src/selections.js"],"names":["buildCypherSelection","initial","cypherParams","selections","variableName","schemaType","resolveInfo","paramIndex","parentSelectionInfo","secondParentSelectionInfo","length","selectionFilters","variableValues","filterParams","shallowFilterParams","reduce","result","key","value","index","headSelection","tailSelections","tailParams","recurse","args","subSelection","subFilterParams","fieldName","isInlineFragment","interfaceLabel","kind","fragmentSelections","selectionSet","fragmentTailParams","substring","lastIndexOf","name","commaIfTail","isScalarSchemaType","schemaTypeField","getFields","fieldType","type","innerSchemaType","astNode","interfaceType","interfaceName","fragments","filter","item","fragment","typeCondition","implementationName","schema","_implementations","find","intfc","customCypher","statement","typeMap","getTypeMap","schemaTypeAstNode","innerSchemaTypeAstNode","innerSchemaTypeRelation","schemaTypeRelation","relType","relDirection","direction","nestedVariable","skipLimit","subSelections","selection","fieldArgs","map","e","temporalArgs","queryParams","fieldInfo","temporalClauses"],"mappings":"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","file":"selections.js","sourcesContent":["import {\n  computeSkipLimit,\n  cypherDirective,\n  cypherDirectiveArgs,\n  filtersFromSelections,\n  innerFilterParams,\n  paramsToString,\n  getFilterParams,\n  innerType,\n  isGraphqlScalarType,\n  extractSelections,\n  relationDirective,\n  getRelationTypeDirectiveArgs,\n  decideNestedVariableName,\n  safeLabel,\n  safeVar,\n  isTemporalType,\n  isTemporalField,\n  getTemporalArguments,\n  temporalPredicateClauses,\n  removeIgnoredFields\n} from './utils';\nimport {\n  customCypherField,\n  relationFieldOnNodeType,\n  relationTypeFieldOnNodeType,\n  nodeTypeFieldOnRelationType,\n  temporalType,\n  temporalField\n} from './translate';\n\nexport function buildCypherSelection({\n  initial,\n  cypherParams,\n  selections,\n  variableName,\n  schemaType,\n  resolveInfo,\n  paramIndex = 1,\n  parentSelectionInfo = {},\n  secondParentSelectionInfo = {}\n}) {\n  if (!selections.length) {\n    return [initial, {}];\n  }\n  selections = removeIgnoredFields(schemaType, selections);\n  const selectionFilters = filtersFromSelections(\n    selections,\n    resolveInfo.variableValues\n  );\n  const filterParams = getFilterParams(selectionFilters, paramIndex);\n  const shallowFilterParams = Object.entries(filterParams).reduce(\n    (result, [key, value]) => {\n      result[`${value.index}_${key}`] = value.value;\n      return result;\n    },\n    {}\n  );\n\n  const [headSelection, ...tailSelections] = selections;\n\n  let tailParams = {\n    selections: tailSelections,\n    cypherParams,\n    variableName,\n    schemaType,\n    resolveInfo,\n    parentSelectionInfo,\n    secondParentSelectionInfo\n  };\n\n  const recurse = args => {\n    paramIndex =\n      Object.keys(shallowFilterParams).length > 0 ? paramIndex + 1 : paramIndex;\n    const [subSelection, subFilterParams] = buildCypherSelection({\n      ...args,\n      ...{ paramIndex }\n    });\n    return [subSelection, { ...shallowFilterParams, ...subFilterParams }];\n  };\n\n  let fieldName;\n  let isInlineFragment = false;\n  let interfaceLabel;\n  if (headSelection) {\n    if (headSelection.kind === 'InlineFragment') {\n      // get selections for the fragment and recurse on those\n      const fragmentSelections = headSelection.selectionSet.selections;\n      let fragmentTailParams = {\n        selections: fragmentSelections,\n        variableName,\n        schemaType,\n        resolveInfo,\n        parentSelectionInfo,\n        secondParentSelectionInfo\n      };\n      return recurse({\n        initial: fragmentSelections.length\n          ? initial\n          : initial.substring(0, initial.lastIndexOf(',')),\n        ...fragmentTailParams\n      });\n    } else {\n      fieldName = headSelection.name.value;\n    }\n  }\n\n  const commaIfTail = tailSelections.length > 0 ? ',' : '';\n  const isScalarSchemaType = isGraphqlScalarType(schemaType);\n  const schemaTypeField = !isScalarSchemaType\n    ? schemaType.getFields()[fieldName]\n    : {};\n  // Schema meta fields(__schema, __typename, etc)\n  if (!isScalarSchemaType && !schemaTypeField) {\n    return recurse({\n      initial: tailSelections.length\n        ? initial\n        : initial.substring(0, initial.lastIndexOf(',')),\n      ...tailParams\n    });\n  }\n\n  const fieldType =\n    schemaTypeField && schemaTypeField.type ? schemaTypeField.type : {};\n  const innerSchemaType = innerType(fieldType); // for target \"type\" aka label\n\n  if (\n    innerSchemaType &&\n    innerSchemaType.astNode &&\n    innerSchemaType.astNode.kind === 'InterfaceTypeDefinition'\n  ) {\n    isInlineFragment = true;\n    // FIXME: remove unused variables\n    const interfaceType = schemaType;\n    const interfaceName = innerSchemaType.name;\n\n    const fragments = headSelection.selectionSet.selections.filter(\n      item => item.kind === 'InlineFragment'\n    );\n\n    // FIXME: this will only handle the first inline fragment\n    const fragment = fragments[0];\n\n    interfaceLabel = fragment.typeCondition.name.value;\n    const implementationName = fragment.typeCondition.name.value;\n\n    const schemaType = resolveInfo.schema._implementations[interfaceName].find(\n      intfc => intfc.name === implementationName\n    );\n  }\n\n  const { statement: customCypher } = cypherDirective(schemaType, fieldName);\n\n  const typeMap = resolveInfo.schema.getTypeMap();\n  const schemaTypeAstNode = typeMap[schemaType].astNode;\n\n  // Database meta fields(_id)\n  if (fieldName === '_id') {\n    return recurse({\n      initial: `${initial}${fieldName}: ID(${safeVar(\n        variableName\n      )})${commaIfTail}`,\n      ...tailParams\n    });\n  }\n  // Main control flow\n  if (isGraphqlScalarType(innerSchemaType)) {\n    if (customCypher) {\n      if (getRelationTypeDirectiveArgs(schemaTypeAstNode)) {\n        variableName = `${variableName}_relation`;\n      }\n      return recurse({\n        initial: `${initial}${fieldName}: apoc.cypher.runFirstColumn(\"${customCypher}\", ${cypherDirectiveArgs(\n          variableName,\n          cypherParams,\n          headSelection,\n          schemaType,\n          resolveInfo\n        )}, false)${commaIfTail}`,\n        ...tailParams\n      });\n    } else if (isTemporalField(schemaType, fieldName)) {\n      return recurse(\n        temporalField({\n          initial,\n          fieldName,\n          variableName,\n          commaIfTail,\n          tailParams,\n          parentSelectionInfo,\n          secondParentSelectionInfo\n        })\n      );\n    }\n    // graphql scalar type, no custom cypher statement\n    return recurse({\n      initial: `${initial} .${fieldName} ${commaIfTail}`,\n      ...tailParams\n    });\n  }\n  // We have a graphql object type\n  const innerSchemaTypeAstNode =\n    innerSchemaType && typeMap[innerSchemaType]\n      ? typeMap[innerSchemaType].astNode\n      : {};\n  const innerSchemaTypeRelation = getRelationTypeDirectiveArgs(\n    innerSchemaTypeAstNode\n  );\n  const schemaTypeRelation = getRelationTypeDirectiveArgs(schemaTypeAstNode);\n  const { name: relType, direction: relDirection } = relationDirective(\n    schemaType,\n    fieldName\n  );\n\n  const nestedVariable = decideNestedVariableName({\n    schemaTypeRelation,\n    innerSchemaTypeRelation,\n    variableName,\n    fieldName,\n    parentSelectionInfo\n  });\n\n  const skipLimit = computeSkipLimit(headSelection, resolveInfo.variableValues);\n\n  const subSelections = extractSelections(\n    headSelection.selectionSet ? headSelection.selectionSet.selections : [],\n    resolveInfo.fragments\n  );\n\n  const subSelection = recurse({\n    initial: '',\n    selections: subSelections,\n    variableName: nestedVariable,\n    schemaType: innerSchemaType,\n    resolveInfo,\n    cypherParams,\n    parentSelectionInfo: {\n      fieldName,\n      schemaType,\n      variableName,\n      fieldType,\n      filterParams,\n      selections\n    },\n    secondParentSelectionInfo: parentSelectionInfo\n  });\n\n  let selection;\n  const fieldArgs =\n    !isScalarSchemaType && schemaTypeField && schemaTypeField.args\n      ? schemaTypeField.args.map(e => e.astNode)\n      : [];\n  const temporalArgs = getTemporalArguments(fieldArgs);\n  const queryParams = paramsToString(\n    innerFilterParams(filterParams, temporalArgs)\n  );\n  const fieldInfo = {\n    initial,\n    fieldName,\n    fieldType,\n    variableName,\n    nestedVariable,\n    queryParams,\n    filterParams,\n    temporalArgs,\n    subSelection,\n    skipLimit,\n    commaIfTail,\n    tailParams\n  };\n  if (customCypher) {\n    // Object type field with cypher directive\n    selection = recurse(\n      customCypherField({\n        ...fieldInfo,\n        cypherParams,\n        schemaType,\n        schemaTypeRelation,\n        customCypher,\n        headSelection,\n        resolveInfo\n      })\n    );\n  } else if (isTemporalType(innerSchemaType.name)) {\n    selection = recurse(\n      temporalType({\n        schemaType,\n        schemaTypeRelation,\n        parentSelectionInfo,\n        ...fieldInfo\n      })\n    );\n  } else if (relType && relDirection) {\n    // Object type field with relation directive\n    const temporalClauses = temporalPredicateClauses(\n      filterParams,\n      nestedVariable,\n      temporalArgs\n    );\n    selection = recurse(\n      relationFieldOnNodeType({\n        ...fieldInfo,\n        schemaType,\n        selections,\n        relDirection,\n        relType,\n        isInlineFragment,\n        interfaceLabel,\n        innerSchemaType,\n        temporalClauses\n      })\n    );\n  } else if (schemaTypeRelation) {\n    // Object type field on relation type\n    // (from, to, renamed, relation mutation payloads...)\n    selection = recurse(\n      nodeTypeFieldOnRelationType({\n        fieldInfo,\n        schemaTypeRelation,\n        innerSchemaType,\n        isInlineFragment,\n        interfaceLabel,\n        paramIndex,\n        schemaType,\n        filterParams,\n        temporalArgs,\n        parentSelectionInfo\n      })\n    );\n  } else if (innerSchemaTypeRelation) {\n    // Relation type field on node type (field payload types...)\n    selection = recurse(\n      relationTypeFieldOnNodeType({\n        ...fieldInfo,\n        innerSchemaTypeRelation,\n        schemaType,\n        filterParams,\n        temporalArgs\n      })\n    );\n  }\n  return [selection[0], { ...selection[1], ...subSelection[1] }];\n}\n"]}